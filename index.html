<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Hand Simulator</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 320px;
        }
        #controls h3 { margin: 0; font-size: 1.1em; }
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #toggle-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            line-height: 1;
        }
        #toggle-btn:hover { background: rgba(255,255,255,0.3); }
        .chord-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .chord-btn:hover { background: #45a049; }
        .chord-btn.active { background: #2196F3; }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #chord-diagram {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-family: monospace;
        }
        #chord-diagram h4 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        .finger-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .finger-name {
            color: #aaa;
        }
        .finger-pos {
            color: #fff;
            font-weight: bold;
        }
        .string-diagram {
            margin-top: 10px;
            font-size: 14px;
            line-height: 1.4;
        }
        .string-line {
            display: flex;
            align-items: center;
        }
        .string-label {
            width: 30px;
            color: #888;
        }
        .fret-display {
            font-family: monospace;
            letter-spacing: 2px;
        }
        .finger-marker {
            color: #4CAF50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="header-row">
            <h3>üé∏ Guitar Chord Simulator</h3>
            <button id="toggle-btn" onclick="togglePanel()">‚àí</button>
        </div>
        <div id="panel-content">
        <div style="display: flex; flex-wrap: wrap;">
            <button class="chord-btn active" onclick="setChord('C')">C Major</button>
            <button class="chord-btn" onclick="setChord('D')">D Major</button>
            <button class="chord-btn" onclick="setChord('G')">G Major</button>
            <button class="chord-btn" onclick="setChord('A')">A Major</button>
            <button class="chord-btn" onclick="setChord('E')">E Major</button>
            <button class="chord-btn" onclick="setChord('F')">F Major</button>
            <button class="chord-btn" onclick="setChord('Am')">A Minor</button>
            <button class="chord-btn" onclick="setChord('Em')">E Minor</button>
            <button class="chord-btn" onclick="setChord('Dm')">D Minor</button>
        </div>
        
        <div id="chord-diagram">
            <h4>üìç Finger Positions</h4>
            <div id="finger-list"></div>
            <div class="string-diagram">
                <div id="fretboard-text"></div>
            </div>
        </div>

        <div id="debug-controls" style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 10px;">
            <h4 style="margin: 0 0 10px 0; color: #ff9800;">üõ† Hand Position</h4>
            
            <div class="control-row" style="display: flex; align-items: center; margin-bottom: 5px;">
                <label style="width: 20px; color: #aaa;">X:</label>
                <input type="range" min="-2" max="2" step="0.1" value="0" oninput="updateHandOffset('x', this.value)" style="flex-grow: 1;">
                <span id="offset-x" style="width: 35px; text-align: right; font-family: monospace; font-size: 0.9em;">0.0</span>
            </div>
            
            <div class="control-row" style="display: flex; align-items: center; margin-bottom: 5px;">
                <label style="width: 20px; color: #aaa;">Y:</label>
                <input type="range" min="-2" max="2" step="0.1" value="0" oninput="updateHandOffset('y', this.value)" style="flex-grow: 1;">
                <span id="offset-y" style="width: 35px; text-align: right; font-family: monospace; font-size: 0.9em;">0.0</span>
            </div>
            
            <div class="control-row" style="display: flex; align-items: center;">
                <label style="width: 20px; color: #aaa;">Z:</label>
                <input type="range" min="-2" max="2" step="0.1" value="0" oninput="updateHandOffset('z', this.value)" style="flex-grow: 1;">
                <span id="offset-z" style="width: 35px; text-align: right; font-family: monospace; font-size: 0.9em;">0.0</span>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button onclick="saveCurrentOffset()" style="background: #ff9800; border: none; padding: 8px; color: white; border-radius: 4px; cursor: pointer; flex-grow: 1; font-weight: bold;">Save Position</button>
                <button onclick="resetCurrentOffset()" style="background: #444; border: none; padding: 8px; color: white; border-radius: 4px; cursor: pointer;">‚Ü∫</button>
            </div>
        </div>
        </div>
    </div>
    <div id="info">
        Drag to rotate | Scroll to zoom | Current chord: <span id="current-chord">C Major</span>
        <div id="camera-info" style="font-size: 0.8em; opacity: 0.7; margin-top: 5px; font-family: monospace;"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position camera - User selected angle (Audience side, very high)
        camera.position.set(-1.7, 7.2, 2.7);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        // Look at the fretboard area where chords are played
        controls.target.set(-2.4, 0.7, -0.3);

        // Update camera position display
        controls.addEventListener('change', updateCameraInfo);
        
        function updateCameraInfo() {
            const p = camera.position;
            const t = controls.target;
            const info = document.getElementById('camera-info');
            if (info) {
                // Determine rough position description for ease of use
                let desc = "";
                if (p.x > 0 && p.z < 0) desc = "(Player Perspective)";
                else if (p.z > 0) desc = "(Audience Perspective)";
                
                info.innerHTML = `Cam: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}<br>Tgt: ${t.x.toFixed(1)}, ${t.y.toFixed(1)}, ${t.z.toFixed(1)} ${desc}`;
            }
        }
        updateCameraInfo(); // Initial update

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // --- GUITAR NECK ---
        const neckGroup = new THREE.Group();
        scene.add(neckGroup);

        // Fretboard wood
        const fretboardGeom = new THREE.BoxGeometry(14, 0.3, 2);
        const fretboardMat = new THREE.MeshStandardMaterial({ color: 0x3d2314 });
        const fretboard = new THREE.Mesh(fretboardGeom, fretboardMat);
        fretboard.receiveShadow = true;
        neckGroup.add(fretboard);

        // Frets (metal bars)
        const fretPositions = [];
        const scaleLength = 12;
        const nutX = -6;
        
        for (let i = 0; i <= 12; i++) {
            const dist = scaleLength - (scaleLength / Math.pow(2, i / 12));
            const fretX = nutX + dist;
            fretPositions.push(fretX);
            
            const fretGeom = new THREE.BoxGeometry(0.08, 0.1, 1.8);
            const fretMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
            const fret = new THREE.Mesh(fretGeom, fretMat);
            fret.position.set(fretX, 0.2, 0);
            neckGroup.add(fret);
            
            // Fret markers
            if ([3, 5, 7, 9, 12].includes(i)) {
                const dotGeom = new THREE.CircleGeometry(0.1, 16);
                const dotMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const dot = new THREE.Mesh(dotGeom, dotMat);
                dot.rotation.x = -Math.PI / 2;
                dot.position.set(fretX - 0.3, 0.16, 0);
                neckGroup.add(dot);
            }
        }

        // Strings
        const stringColors = [0xe8e8e8, 0xe0e0e0, 0xd8d8d8, 0xb8b8b8, 0xa8a8a8, 0x989898];
        const strings = [];
        for (let i = 0; i < 6; i++) {
            const thickness = 0.015 + i * 0.005;
            const stringGeom = new THREE.CylinderGeometry(thickness, thickness, 13, 8);
            const stringMat = new THREE.MeshStandardMaterial({ color: stringColors[i], metalness: 0.9, roughness: 0.3 });
            const string = new THREE.Mesh(stringGeom, stringMat);
            string.rotation.z = Math.PI / 2;
            const yPos = 0.7 - i * 0.28;
            string.position.set(0, 0.35, yPos);
            neckGroup.add(string);
            strings.push({ mesh: string, y: yPos });
        }

        // --- HAND SYSTEM ---
        // Just fingers - clean and functional
        
        const handGroup = new THREE.Group();
        scene.add(handGroup);

        // Marker group for indicating finger positions on fretboard
        const markerGroup = new THREE.Group();
        scene.add(markerGroup);

        // Placeholder groups (kept for compatibility but empty)
        const palmGroup = new THREE.Group();
        handGroup.add(palmGroup);
        
        const thumbGroup = new THREE.Group();
        thumbGroup.visible = false; // Hide thumb - looks weird without palm
        scene.add(thumbGroup);

        // Finger colors for visualization
        const fingerColors = [0x00ffff, 0xffff00, 0xff8800, 0xff88ff]; // Cyan, Yellow, Orange, Pink
        const fingerNames = ['Index', 'Middle', 'Ring', 'Pinky'];

        // Finger class
        class Finger {
            constructor(color, knuckleOffset, lengths) {
                this.knuckleOffset = knuckleOffset;
                this.lengths = lengths; // [proximal, intermediate, distal]
                this.segments = [];
                this.joints = [];
                this.targetPos = new THREE.Vector3();

                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });

                // Create 3 finger segments (phalanges)
                for (let i = 0; i < 3; i++) {
                    const thickness = 0.11 - i * 0.02;
                    const segGeom = new THREE.CapsuleGeometry(thickness, lengths[i], 4, 8);
                    const seg = new THREE.Mesh(segGeom, mat);
                    seg.castShadow = true;
                    scene.add(seg); // Add directly to scene for easier positioning
                    this.segments.push(seg);
                }

                // Joint spheres at each knuckle
                for (let i = 0; i < 4; i++) {
                    const size = 0.12 - i * 0.02;
                    const jointGeom = new THREE.SphereGeometry(size, 8, 8);
                    const joint = new THREE.Mesh(jointGeom, mat);
                    joint.castShadow = true;
                    scene.add(joint); // Add directly to scene
                    this.joints.push(joint);
                }
            }

            setTarget(pos) {
                this.targetPos.copy(pos);
            }

            update(knuckleWorldPos) {
                // Spline-based IK: Guarantees fingertips hit the target
                // Uses a Quadratic Bezier curve to define the finger arc
                
                const p0 = knuckleWorldPos;
                const p2 = this.targetPos;
                
                // Control point (P1) - creates the arc
                // Positioned halfway between knuckle and target, but raised UP to clear fretboard
                const p1 = new THREE.Vector3().addVectors(p0, p2).multiplyScalar(0.5);
                
                // Height adjustment: Ensure we clear the neck
                // Fretboard is at Y ~= 0.35. We want to go well above that.
                // Dynamic height based on reach distance
                const dist = p0.distanceTo(p2);
                p1.y = Math.max(p0.y, p2.y) + 0.6 + (dist * 0.15);
                
                // Also pull P1 slightly "out" (negative Z) if reaching across neck
                // to prevent clipping through the neck wood
                p1.z -= 0.2; 
                
                // Bezier function
                function getBezierPoint(t, p0, p1, p2) {
                    const u = 1 - t;
                    const tt = t * t;
                    const uu = u * u;
                    
                    const p = new THREE.Vector3();
                    p.x = uu * p0.x + 2 * u * t * p1.x + tt * p2.x;
                    p.y = uu * p0.y + 2 * u * t * p1.y + tt * p2.y;
                    p.z = uu * p0.z + 2 * u * t * p1.z + tt * p2.z;
                    return p;
                }
                
                // Calculate joint positions along the curve
                // We divide the curve roughly based on segment length ratios
                const totalLen = this.lengths.reduce((a,b)=>a+b, 0);
                const t1 = this.lengths[0] / totalLen; // End of first segment
                const t2 = (this.lengths[0] + this.lengths[1]) / totalLen; // End of second segment
                
                const joint1Pos = getBezierPoint(t1, p0, p1, p2);
                const joint2Pos = getBezierPoint(t2, p0, p1, p2);
                
                const positions = [p0, joint1Pos, joint2Pos, p2];
                
                // Update visuals
                for (let i = 0; i < 4; i++) {
                    this.joints[i].position.copy(positions[i]);
                }
                
                for (let i = 0; i < 3; i++) {
                    const start = positions[i];
                    const end = positions[i+1];
                    const mid = new THREE.Vector3().lerpVectors(start, end, 0.5);
                    const segLen = start.distanceTo(end);
                    
                    this.segments[i].position.copy(mid);
                    this.segments[i].lookAt(end);
                    this.segments[i].rotateX(Math.PI / 2);
                    
                    // Minor stretch/squash to ensure connectivity
                    // Original geometry height is this.lengths[i]
                    this.segments[i].scale.set(1, segLen / this.lengths[i], 1);
                }
            }
        }

        // Create fingers with offsets from palm and segment lengths
        // Using skin tones - fingers need to be long enough to reach from knuckle to string
        // REORDERED OFFSETS: Index starts at lowest X (left) to Pinky at highest X (right)
        // to prevent fingers from crossing over each other when reaching for frets.
        const fingers = [];
        const skinTones = [0xf5c9a6, 0xf2c4a0, 0xf0c19a, 0xeebb94]; // Slight variations
        const fingerConfigs = [
            { offset: new THREE.Vector3(-0.35, 0, 0), lengths: [0.5, 0.4, 0.3] },   // Index - Leftmost
            { offset: new THREE.Vector3(-0.10, 0, 0), lengths: [0.58, 0.45, 0.32] },  // Middle
            { offset: new THREE.Vector3(0.15, 0, 0), lengths: [0.54, 0.42, 0.3] },   // Ring
            { offset: new THREE.Vector3(0.40, 0, 0), lengths: [0.44, 0.35, 0.26] },   // Pinky - Rightmost
        ];

        for (let i = 0; i < 4; i++) {
            const finger = new Finger(
                skinTones[i],
                fingerConfigs[i].offset,
                fingerConfigs[i].lengths
            );
            fingers.push(finger);
        }

        // Knuckle positions will be calculated based on palm position
        let knucklePositions = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];

        // --- CHORD DEFINITIONS ---
        // Format: array of { string: 1-6, fret: 0-12, finger: 0-3 }
        const chords = {
            'C': [
                { string: 2, fret: 1, finger: 0 },
                { string: 4, fret: 2, finger: 1 },
                { string: 5, fret: 3, finger: 2 },
            ],
            'D': [
                { string: 3, fret: 2, finger: 0 },
                { string: 1, fret: 2, finger: 1 },
                { string: 2, fret: 3, finger: 2 },
            ],
            'G': [
                { string: 5, fret: 2, finger: 0 },
                { string: 6, fret: 3, finger: 1 },
                { string: 1, fret: 3, finger: 2 },
                { string: 2, fret: 3, finger: 3 },
            ],
            'A': [
                { string: 4, fret: 2, finger: 0 },
                { string: 3, fret: 2, finger: 1 },
                { string: 2, fret: 2, finger: 2 },
            ],
            'E': [
                { string: 3, fret: 1, finger: 0 },
                { string: 5, fret: 2, finger: 1 },
                { string: 4, fret: 2, finger: 2 },
            ],
            'F': [
                { string: 2, fret: 1, finger: 0 },
                { string: 3, fret: 2, finger: 1 },
                { string: 5, fret: 3, finger: 2 },
                { string: 4, fret: 3, finger: 3 }, 
            ],
            'Am': [
                { string: 2, fret: 1, finger: 0 },
                { string: 4, fret: 2, finger: 1 },
                { string: 3, fret: 2, finger: 2 },
            ],
            'Em': [
                { string: 5, fret: 2, finger: 1 },
                { string: 4, fret: 2, finger: 2 },
            ],
            'Dm': [
                { string: 1, fret: 1, finger: 0 },
                { string: 3, fret: 2, finger: 1 },
                { string: 2, fret: 3, finger: 2 },
            ]
        };

        // Initial hand offsets for each chord
        const defaultChordOffsets = {
            'C': { x: 0, y: 0, z: 0 },
            'D': { x: -1, y: 0, z: 0 },
            'G': { x: -0.3, y: 1, z: 0.2 },
            'A': { x: -1, y: 0.4, z: 0 },
            'E': { x: -0.1, y: 0.8, z: 0 },
            'F': { x: 0, y: 0, z: 0 },
            'Am': { x: 0, y: 0, z: 0 },
            'Em': { x: 0, y: 0, z: 0 },
            'Dm': { x: 0, y: 0, z: 0 }
        };
        
        // Load saved offsets from LocalStorage
        const savedOffsets = JSON.parse(localStorage.getItem('guitarHandOffsets')) || {};
        const chordOffsets = { ...defaultChordOffsets, ...savedOffsets };

        // Save current offset to LocalStorage
        window.saveCurrentOffset = function() {
            if (!currentChord) return;
            
            // Update the master list
            chordOffsets[currentChord] = { x: handOffset.x, y: handOffset.y, z: handOffset.z };
            
            // Persist to storage
            localStorage.setItem('guitarHandOffsets', JSON.stringify(chordOffsets));
            
            // Visual feedback
            const btn = document.querySelector('button[onclick="saveCurrentOffset()"]');
            const originalText = btn.textContent;
            btn.textContent = "Saved!";
            btn.style.background = "#4CAF50";
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = "#ff9800";
            }, 1000);
        };

        // Reset current offset to defaults
        window.resetCurrentOffset = function() {
            if (!currentChord || !defaultChordOffsets[currentChord]) return;
            
            // Revert checks
            const def = defaultChordOffsets[currentChord];
            handOffset.set(def.x, def.y, def.z);
            chordOffsets[currentChord] = { ...def };
            
            // Update UI inputs
            ['x', 'y', 'z'].forEach(axis => {
                const selector = `input[oninput*="'${axis}'"]`;
                const input = document.querySelector(selector);
                if (input) input.value = handOffset[axis];
                
                const display = document.getElementById(`offset-${axis}`);
                if (display) display.textContent = handOffset[axis].toFixed(1);
            });
            
            // Save the revert
            localStorage.setItem('guitarHandOffsets', JSON.stringify(chordOffsets));
            
            // Update view
            setChord(currentChord);
        };

        // Get note position on fretboard
        function getNotePosition(string, fret) {
            const stringIdx = 6 - string; // Convert 1-6 to index
            const y = strings[stringIdx].y;
            
            let x;
            if (fret === 0) {
                x = fretPositions[0] - 0.5;
            } else {
                x = (fretPositions[fret] + fretPositions[fret - 1]) / 2;
            }
            
            return new THREE.Vector3(x, 0.5, y);
        }

        // Current chord state
        let currentChord = null;
        let fingerTargets = [null, null, null, null];
        let palmPosition = new THREE.Vector3(-4, -1, 1.5);
        
        // Debug offsets
        let handOffset = new THREE.Vector3(0, 0, 0);

        window.updateHandOffset = function(axis, value) {
            value = parseFloat(value);
            handOffset[axis] = value;
            document.getElementById(`offset-${axis}`).textContent = value.toFixed(1);
            setChord(currentChord);
        };

        function setChord(chordName) {
            // Apply preset offsets if switching chords
            if (chordName !== currentChord) {
                const offsets = chordOffsets[chordName] || { x: 0, y: 0, z: 0 };
                handOffset.copy(offsets);
                
                // Update UI sliders and text
                ['x', 'y', 'z'].forEach(axis => {
                    const selector = `input[oninput*="'${axis}'"]`;
                    const input = document.querySelector(selector);
                    if (input) input.value = handOffset[axis];
                    
                    const display = document.getElementById(`offset-${axis}`);
                    if (display) display.textContent = handOffset[axis].toFixed(1);
                });
            }

            currentChord = chordName;
            document.getElementById('current-chord').textContent = chordName;
            
            // Update button states
            document.querySelectorAll('.chord-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(chordName)) btn.classList.add('active');
            });

            // Reset targets
            fingerTargets = [null, null, null, null];
            
            // Clear previous markers
            markerGroup.clear();

            // Set finger targets from chord
            const chord = chords[chordName];
            let avgX = 0, avgZ = 0, count = 0;
            
            for (const note of chord) {
                const pos = getNotePosition(note.string, note.fret);
                fingerTargets[note.finger] = pos;

                // Add visual marker on fretboard
                if (note.fret > 0) {
                    const markerGeom = new THREE.CircleGeometry(0.12, 16);
                    const markerMat = new THREE.MeshBasicMaterial({ 
                        color: fingerColors[note.finger],
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const marker = new THREE.Mesh(markerGeom, markerMat);
                    marker.rotation.x = -Math.PI / 2;
                    // Place slightly above fretboard surface (y=0.15)
                    marker.position.set(pos.x, 0.16, pos.z); 
                    markerGroup.add(marker);
                    
                    // Add a glowing ring effect
                    const ringGeom = new THREE.RingGeometry(0.14, 0.17, 16);
                    const ringMat = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeom, ringMat);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.set(pos.x, 0.162, pos.z);
                    markerGroup.add(ring);
                }

                avgX += pos.x;
                avgZ += pos.z;
                count++;
            }
            avgX /= count;
            avgZ /= count;

            // Position hand: knuckles BELOW the neck, on player's side
            // Fingers reach UP, wrap over the neck edge, curl DOWN to press strings
            // Just like the reference photo
            
            // Apply offsets
            const avgX_off = avgX + handOffset.x;
            const knuckleY = -0.4 + handOffset.y;  // Below the fretboard
            const knuckleZ = avgZ - 1.2 + handOffset.z;   // Just behind the target strings
            
            // Position palm behind neck
            palmPosition.set(avgX_off, knuckleY - 0.5, knuckleZ + 0.3);
            palmGroup.position.copy(palmPosition);
            palmGroup.rotation.set(-0.3, 0, 0); // Tilted back
            
            // Thumb position (hidden but kept for compatibility)
            thumbGroup.position.set(avgX_off + 0.1, 0.5, knuckleZ + 0.5);
            
            // Calculate knuckle positions (behind neck, below fretboard)
            for (let i = 0; i < 4; i++) {
                const xOffset = fingerConfigs[i].offset.x;
                // Stagger knuckles - middle finger knuckle slightly higher (natural hand arch)
                const yOffset = [0, 0.08, 0.06, -0.04][i]; 
                
                // Add tiny Z stagger to prevent Z-fighting if fingers are close
                const zStagger = i * 0.05; 
                
                knucklePositions[i].set(
                    avgX_off + xOffset,
                    knuckleY + yOffset,
                    knuckleZ + zStagger
                );
            }

            // Set unused fingers to hover curled
            // prevent crossing by interpolating between neighbors if possible
            for (let i = 0; i < 4; i++) {
                if (!fingerTargets[i]) {
                    // Start with default position based on hand center
                    let targetX = avgX_off + fingerConfigs[i].offset.x;
                    let targetZ = avgZ;

                    // Try to be smarter: stay between neighbors in the schematic order (Index -> Pinky)
                    // Find nearest active neighbor to left (< i) and right (> i)
                    let left = -1;
                    let right = -1;
                    
                    // Look left (lower index)
                    for(let j=i-1; j>=0; j--) {
                        if(fingerTargets[j]) { left = j; break; }
                    }
                    // Look right (higher index)
                    for(let j=i+1; j<4; j++) {
                        if(fingerTargets[j]) { right = j; break; }
                    }
                    
                    if (left !== -1 && right !== -1) {
                         // We are sandwiched. Place proportionally between them.
                         const range = fingerConfigs[right].offset.x - fingerConfigs[left].offset.x;
                         const myRel = (fingerConfigs[i].offset.x - fingerConfigs[left].offset.x) / range;
                         
                         const worldRange = fingerTargets[right].x - fingerTargets[left].x;
                         targetX = fingerTargets[left].x + worldRange * myRel;
                         
                         // Also interpolate Z to keep the "line" of fingers smooth
                         const worldRangeZ = fingerTargets[right].z - fingerTargets[left].z;
                         targetZ = fingerTargets[left].z + worldRangeZ * myRel;

                    } else if (left !== -1) {
                        // Only left neighbor. Keep minimal distance to right of it.
                        // maintain at least the natural spacing
                        const spacing = fingerConfigs[i].offset.x - fingerConfigs[left].offset.x;
                        targetX = Math.max(targetX, fingerTargets[left].x + spacing * 0.8);
                        targetZ = fingerTargets[left].z; // Roughly same Z (string) depth
                        
                    } else if (right !== -1) {
                        // Only right neighbor. Keep minimal distance to left of it.
                         const spacing = fingerConfigs[right].offset.x - fingerConfigs[i].offset.x;
                         targetX = Math.min(targetX, fingerTargets[right].x - spacing * 0.8);
                         targetZ = fingerTargets[right].z;
                    }
                    
                    // Lift unused fingers higher
                    fingerTargets[i] = new THREE.Vector3(
                        targetX,
                        0.8,  // Above fretboard
                        targetZ
                    );
                }
            }
            
            // Update the chord diagram display
            updateChordDiagram(chordName, chord);
        }
        
        // Function to display chord fingering information
        function updateChordDiagram(chordName, chord) {
            const fingerNames = ['Index (1)', 'Middle (2)', 'Ring (3)', 'Pinky (4)'];
            const stringNames = ['e (1)', 'B (2)', 'G (3)', 'D (4)', 'A (5)', 'E (6)'];
            
            // Build finger position list
            let fingerHtml = '';
            for (const note of chord) {
                fingerHtml += `<div class="finger-row">
                    <span class="finger-name">${fingerNames[note.finger]}:</span>
                    <span class="finger-pos">String ${note.string} (${stringNames[note.string-1]}), Fret ${note.fret}</span>
                </div>`;
            }
            document.getElementById('finger-list').innerHTML = fingerHtml;
            
            // Build ASCII fretboard diagram
            let fretboardHtml = '<pre style="margin:0;color:#ccc;">';
            fretboardHtml += '     Fret: 0   1   2   3   4\n';
            fretboardHtml += '          nut ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ\n';
            
            for (let s = 1; s <= 6; s++) {
                const label = stringNames[s-1].padEnd(6);
                let line = label + '‚îÇ';
                
                for (let f = 1; f <= 4; f++) {
                    // Check if any finger is on this string/fret
                    const note = chord.find(n => n.string === s && n.fret === f);
                    if (note) {
                        line += ` ${note.finger + 1} ‚îÇ`;
                    } else {
                        line += '‚îÄ‚îÄ‚îÄ‚îÇ';
                    }
                }
                fretboardHtml += line + '\n';
            }
            fretboardHtml += '</pre>';
            
            document.getElementById('fretboard-text').innerHTML = fretboardHtml;
        }

        // Make setChord available globally
        window.setChord = setChord;

        window.togglePanel = function() {
            const content = document.getElementById('panel-content');
            const btn = document.getElementById('toggle-btn');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = '‚àí';
            } else {
                content.style.display = 'none';
                btn.textContent = '+';
            }
        };

        // Initialize with C chord
        setChord('C');

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Update each finger's IK from its knuckle position
            for (let i = 0; i < 4; i++) {
                if (fingerTargets[i]) {
                    fingers[i].setTarget(fingerTargets[i]);
                    fingers[i].update(knucklePositions[i]);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if (e.key === '1') setChord('C');
            if (e.key === '2') setChord('D');
            if (e.key === '3') setChord('G');
            if (e.key === '4') setChord('A');
            if (e.key === '5') setChord('E');
            if (e.key === '6') setChord('F');
            if (e.key === '7') setChord('Am');
            if (e.key === '8') setChord('Em');
            if (e.key === '9') setChord('Dm');
        });
    </script>
</body>
</html>
