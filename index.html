<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Hand Simulator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Palette */
            --bg-color: #0f172a;
            --panel-bg: rgba(30, 41, 59, 0.7);
            --panel-border: rgba(255, 255, 255, 0.1);
            
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --secondary: #64748b;
            --accent: #10b981;
            --danger: #ef4444;
            
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            
            --radius-md: 12px;
            --radius-sm: 6px;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }

        * { box-sizing: border-box; }

        body { 
            margin: 0; 
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            width: 100vw;
            height: 100vh;
        }

        canvas { 
            display: block; 
            position: absolute; 
            top: 0; left: 0; z-index: 0; 
        }

        /* --- UI UTILS --- */
        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
        }

        /* --- CONTROLS PANEL --- */
        #controls {
            position: absolute;
            z-index: 10;
            top: 24px; left: 24px;
            width: 340px;
            max-height: calc(100vh - 48px);
            display: flex;
            flex-direction: column;
            padding: 0; /* Content padding handled inside */
            overflow: hidden; /* Clear floats/margins */
        }
        
        .panel-header {
            padding: 16px 20px;
            background: rgba(255,255,255,0.03);
            border-bottom: 1px solid var(--panel-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header h3 { margin: 0; font-weight: 600; font-size: 16px; letter-spacing: -0.01em; }

        /* Icon Button */
        .icon-btn {
            background: transparent;
            border: 1px solid var(--panel-border);
            color: var(--text-muted);
            width: 28px; height: 28px;
            border-radius: var(--radius-sm);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .icon-btn:hover { background: rgba(255,255,255,0.1); color: white; }

        #panel-content {
            padding: 20px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--secondary) transparent;
        }
        
        /* Custom Scrollbar */
        #panel-content::-webkit-scrollbar { width: 6px; }
        #panel-content::-webkit-scrollbar-thumb { background-color: var(--secondary); border-radius: 4px; }
        #panel-content::-webkit-scrollbar-track { bg: transparent; }

        /* --- CHORD GRID --- */
        #chord-buttons-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 8px;
            margin-bottom: 20px;
        }

        .chord-btn {
            background-color: rgba(255,255,255,0.05);
            border: 1px solid transparent;
            color: var(--text-main);
            padding: 10px 4px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
        }
        .chord-btn:hover {
            background-color: rgba(255,255,255,0.1);
            transform: translateY(-1px);
        }
        .chord-btn.active {
            background-color: var(--primary);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            border-color: rgba(255,255,255,0.2);
            font-weight: 600;
        }

        /* --- ACTION BUTTONS --- */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 16px;
            border: none;
            border-radius: var(--radius-sm);
            font-family: inherit;
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            gap: 6px;
        }
        .btn-full { width: 100%; }
        .btn-secondary { background: rgba(255,255,255,0.08); color: var(--text-main); }
        .btn-secondary:hover { background: rgba(255,255,255,0.15); }
        
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }

        .btn-danger { background: rgba(239, 68, 68, 0.2); color: #fca5a5; }
        .btn-danger:hover { background: rgba(239, 68, 68, 0.3); }

        /* --- DIAGRAM & DEBUG --- */
        #chord-diagram {
            margin-top: 24px;
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-sm);
            padding: 16px;
            border: 1px solid var(--panel-border);
        }
        #chord-diagram h4 { margin: 0 0 12px 0; color: var(--text-muted); font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; }

        .finger-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 13px;
        }
        .finger-row:last-child { border-bottom: none; }
        .finger-name { color: var(--text-muted); }
        .finger-pos { font-family: 'JetBrains Mono', monospace; font-size: 12px; }

        .string-diagram pre {
            margin: 12px 0 0 0;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        #debug-controls {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--panel-border);
        }
        .control-row { display: flex; align-items: center; margin-bottom: 12px; font-size: 13px; }
        .control-row label { width: 24px; font-weight: 500; color: var(--text-muted); }
        .control-row span { width: 40px; text-align: right; font-feature-settings: "tnum"; font-variant-numeric: tabular-nums; color: var(--text-main); }
        
        /* Sliders */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 0 12px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 14px; width: 14px;
            border-radius: 50%;
            background: var(--primary);
            -webkit-appearance: none;
            margin-top: -5px;
            box-shadow: 0 0 0 2px var(--bg-color);
            cursor: grab;
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:active { transform: scale(1.2); }

        /* --- MODAL --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(8px);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #1e293b;
            border: 1px solid var(--panel-border);
            border-radius: var(--radius-md);
            width: 90%; max-width: 520px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 20px 20px 50px rgba(0,0,0,0.5);
            animation: modalSlide 0.3s ease-out;
        }
        @keyframes modalSlide { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--panel-border);
            display: flex; justify-content: space-between; align-items: center;
        }
        .modal-header h2 { margin: 0; font-size: 18px; font-weight: 600; }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--panel-border);
            background: rgba(0,0,0,0.1);
            display: flex; gap: 12px;
        }

        /* Forms */
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-size: 12px; font-weight: 500; text-transform: uppercase; color: var(--text-muted); }
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px 12px;
            background: #0f172a;
            border: 1px solid var(--panel-border);
            border-radius: var(--radius-sm);
            color: white;
            font-family: inherit; font-size: 14px;
            transition: border-color 0.2s;
        }
        input:focus, select:focus { outline: none; border-color: var(--primary); }

        .string-row {
            display: grid;
            grid-template-columns: 80px 1fr 1fr;
            gap: 12px;
            align-items: center;
            background: rgba(255,255,255,0.02);
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            margin-bottom: 8px;
            border: 1px solid transparent;
        }
        .string-row:hover { border-color: var(--panel-border); }
        
        .reset-bar {
            margin-bottom: 24px;
        }
    </style>
</head>
<body>

    <!-- CONTROL PANEL -->
    <div id="controls" class="glass-panel">
        <div class="panel-header">
            <h3>üé∏ Hand Simulator</h3>
            <button id="toggle-btn" onclick="togglePanel()" class="icon-btn" title="Toggle Panel">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </button>
        </div>
        
        <div id="panel-content">
            <!-- Chord Buttons Grid -->
            <div id="chord-buttons-container"></div>
            
            <button id="manage-btn" class="btn btn-secondary btn-full" onclick="openModal()">
                <span>‚ûï</span> Add Custom
            </button>

            <!-- Active Chord Info -->
            <div id="chord-diagram">
                <h4>üìç Finger Positions</h4>
                <div id="finger-list"></div>
                <div class="string-diagram">
                    <div id="fretboard-text"></div>
                </div>
            </div>

            <!-- Hand Transformation Controls -->
            <div id="debug-controls">
                <h4 style="margin: 0 0 16px 0; color: var(--text-main); font-size: 13px;">üõ† Hand Adjustment</h4>
                
                <div class="control-row">
                    <label>X</label>
                    <input type="range" min="-1" max="1" step="0.1" value="0" oninput="uiManager.updateHandOffset('x', this.value)">
                    <span id="offset-x">0.0</span>
                </div>
                <div class="control-row">
                    <label>Y</label>
                    <input type="range" min="-1" max="1" step="0.1" value="0" oninput="uiManager.updateHandOffset('y', this.value)">
                    <span id="offset-y">0.0</span>
                </div>
                
                <div style="margin-top: 16px; display: grid; grid-template-columns: 1fr auto; gap: 8px;">
                    <button onclick="uiManager.saveCurrentOffset()" class="btn btn-primary">Save Offset</button>
                    <button onclick="uiManager.resetCurrentOffset()" class="btn btn-secondary icon-btn" title="Reset">‚Ü∫</button>
                </div>
            </div>
        </div>
    </div>

    <!-- INFO OVERLAY -->
    <div id="info">
        Drag to rotate | Scroll to zoom | Current: <span id="current-chord-display">C</span>
        <div id="camera-info" style="font-size: 0.8em; opacity: 0.7; margin-top: 5px; font-family: monospace;"></div>
    </div>

    <!-- MODAL -->
    <div id="chordModal" class="modal">
        <div class="modal-content glass-panel">
            <div class="modal-header">
                <h2>Manage Library</h2>
                <button class="icon-btn" onclick="closeModal()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            
            <div class="modal-body">
                <div class="reset-bar">
                    <button class="btn btn-secondary btn-full" onclick="libraryManager.resetLibrary()">
                         Reset Library to Defaults
                    </button>
                    <p style="text-align: center; font-size: 11px; opacity: 0.5; margin-top: 8px;">
                        (Reloads from js/chords/ folders)
                    </p>
                </div>

                <div class="divider"></div>

                <h3>Chord Editor</h3>
                <div class="form-group">
                    <label>Chord Name</label>
                    <input type="text" id="edit-name" placeholder="e.g. Bm7">
                </div>

                <div id="string-inputs">
                    <!-- Generated by JS -->
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn btn-secondary" id="delete-chord-btn" onclick="deleteChord()" style="display:none; color: #ff6b6b;">Delete</button>
                <div style="flex-grow: 1;"></div>
                <button class="btn btn-primary" onclick="saveChordFromForm()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- THREE.JS IMPORT MAP -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- APP SCRIPT -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Import Chord Libraries
        import { OPEN_CHORDS } from './js/chords/open.js';
        import { BARRE_CHORDS } from './js/chords/barre.js';
        import { TRIAD_CHORDS } from './js/chords/triads.js';
        import { QUADRIAD_CHORDS } from './js/chords/quadriads.js';

        // ==========================================
        // DATA & LIBRARY MANAGER
        // ==========================================
        const DEFAULTS = {
            chords: {
                ...OPEN_CHORDS,
                ...BARRE_CHORDS,
                ...TRIAD_CHORDS,
                ...QUADRIAD_CHORDS
            },
            offsets: {
                // Generic Open Chords
                'C Open': { x: 0, y: 0 },
                'A Open': { x: -1, y: 0.4 },
                'G Open': { x: -0.3, y: 1 },
                'E Open': { x: -0.1, y: 0.8 },
                'D Open': { x: -1, y: 0 },
                'Am Open': { x: 0, y: 0 },
                'Em Open': { x: 0, y: 0 },
                'Dm Open': { x: 0, y: 0 },
                
                // Generic Barres (Defaults usually work via auto-barre logic, but we can tune)
                // Most barre chords use the auto-calculation, but we can force start points
                'F (Barre 1fr)': { x: -0.2, y: -0.2 },
                'Bm (Barre 2fr)': { x: -0.2, y: -0.2 }
            }
        };

        const LibraryManager = {
            data: { chords: {}, offsets: {} },

            async init() {
                // Initialize directly from Storage or Defaults
                // No external fetch for defaults.yaml
                this.loadFromStorage();
            },

            loadFromStorage() {
                const saved = localStorage.getItem('guitarChordLibrary');
                if (saved) {
                    try {
                        let parsed = JSON.parse(saved);
                        this.loadData(parsed);
                    } catch(e) { console.error("Corrupt library", e); this.resetDataToDefaults(); }
                } else {
                    this.resetDataToDefaults();
                }
            },

            loadData(parsed) {
                if (!parsed) return; // Guard against null

                // VALIDATION check
                let dirty = false;
                if(parsed.chords) {
                    for(let k in parsed.chords) {
                        if(Array.isArray(parsed.chords[k])) {
                            parsed.chords[k] = { positions: parsed.chords[k], tags: [] };
                            dirty = true;
                        }
                    }
                }

                this.data = parsed;
                // Structure check
                if(!this.data.chords) this.data.chords = JSON.parse(JSON.stringify(DEFAULTS.chords));
                if(!this.data.offsets) this.data.offsets = JSON.parse(JSON.stringify(DEFAULTS.offsets));
                
                // If we loaded something that needed migration, save it back if using storage
                // but since we prioritize file, maybe not needed.
            },

            resetDataToDefaults() {
                // Hardcoded fallback if file is missing
                this.data.chords = JSON.parse(JSON.stringify(DEFAULTS.chords));
                this.data.offsets = JSON.parse(JSON.stringify(DEFAULTS.offsets));
            },

            save() {
                localStorage.setItem('guitarChordLibrary', JSON.stringify(this.data));
                uiManager.renderChordButtons();
            },

            resetLibrary() {
                if(confirm("Reset entire library to defaults?")) {
                    localStorage.removeItem('guitarChordLibrary');
                    localStorage.removeItem('guitarHandOffsets');
                    this.resetDataToDefaults();
                    this.save();
                    window.location.reload(); 
                }
            }
        };

        // ==========================================
        // 3D SCENE & ENGINE
        // ==========================================
        const GuitarApp = {
            scene: null, camera: null, renderer: null, controls: null,
            neckGroup: null, handGroup: null, markerGroup: null,
            fingers: [], knucklePositions: [],
            currentChordName: null,
            handOffset: new THREE.Vector3(),
            palmPosition: new THREE.Vector3(-4, -1, 1.5), // Base Palm Pos
            fingerTargets: [null, null, null, null],
            
            // Animation State
            actualFingerPositions: [],
            actualKnucklePositions: [],
            transitionSpeed: 0.15, // Speed of interpolation

            // Configs
            strings: [],
            fretPositions: [], 
            stringColors: [0xe8e8e8, 0xe0e0e0, 0xd8d8d8, 0xb8b8b8, 0xa8a8a8, 0x989898],
            fingerColors: [0x00ffff, 0xffff00, 0xff8800, 0xff88ff],
            skinTones: [0xf5c9a6, 0xf2c4a0, 0xf0c19a, 0xeebb94],
            fingerConfigs: [
                { offset: new THREE.Vector3(-0.35, 0, 0), lengths: [0.5, 0.4, 0.3] },   // Index
                { offset: new THREE.Vector3(-0.10, 0, 0), lengths: [0.58, 0.45, 0.32] },  // Middle
                { offset: new THREE.Vector3(0.15, 0, 0), lengths: [0.54, 0.42, 0.3] },   // Ring
                { offset: new THREE.Vector3(0.40, 0, 0), lengths: [0.44, 0.35, 0.26] }   // Pinky
            ],

            init() {
                // Setup Three.js Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(-1.7, 7.2, 2.7);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.target.set(-2.4, 0.7, -0.3);
                this.controls.addEventListener('change', () => this.updateCameraInfo());

                this.addLights();
                this.buildNeck();
                this.buildHand();
                
                this.updateCameraInfo();
                this.animate();

                // Listeners
                window.addEventListener('resize', () => this.onResize());
            },

            addLights() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambient);
                const dir = new THREE.DirectionalLight(0xffffff, 1);
                dir.position.set(5, 10, 5);
                dir.castShadow = true;
                this.scene.add(dir);
            },

            buildNeck() {
                this.neckGroup = new THREE.Group();
                this.scene.add(this.neckGroup);

                // Fretboard
                const board = new THREE.Mesh(
                    new THREE.BoxGeometry(14, 0.3, 2),
                    new THREE.MeshStandardMaterial({ color: 0x3d2314 })
                );
                board.receiveShadow = true;
                this.neckGroup.add(board);

                // Frets
                const scaleLength = 12;
                const nutX = -6;
                for (let i = 0; i <= 12; i++) {
                    const dist = scaleLength - (scaleLength / Math.pow(2, i / 12));
                    const fretX = nutX + dist;
                    this.fretPositions.push(fretX);
                    
                    const fret = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.1, 1.8),
                        new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 })
                    );
                    fret.position.set(fretX, 0.2, 0);
                    this.neckGroup.add(fret);

                    if ([3, 5, 7, 9, 12].includes(i)) {
                        const dot = new THREE.Mesh(
                            new THREE.CircleGeometry(0.1, 16),
                            new THREE.MeshStandardMaterial({ color: 0xffffff })
                        );
                        dot.rotation.x = -Math.PI / 2;
                        dot.position.set(fretX - 0.3, 0.16, 0);
                        this.neckGroup.add(dot);
                    }
                }

                // Strings
                for (let i = 0; i < 6; i++) {
                    const thickness = 0.015 + i * 0.005;
                    const yPos = 0.7 - i * 0.28;
                    const strMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(thickness, thickness, 13, 8),
                        new THREE.MeshStandardMaterial({ color: this.stringColors[i], metalness: 0.9, roughness: 0.3 })
                    );
                    strMesh.rotation.z = Math.PI / 2;
                    strMesh.position.set(0, 0.35, yPos);
                    this.neckGroup.add(strMesh);
                    this.strings.push({ mesh: strMesh, y: yPos });
                }
            },

            buildHand() {
                this.handGroup = new THREE.Group();
                this.scene.add(this.handGroup);
                
                this.markerGroup = new THREE.Group();
                this.scene.add(this.markerGroup);

                // Initialize Fingers
                for (let i = 0; i < 4; i++) {
                    const fConfig = this.fingerConfigs[i];
                    // Using distinct colors for fingers as requested
                    const f = new Finger(this.fingerColors[i], fConfig.offset, fConfig.lengths, this.scene);
                    this.fingers.push(f);
                    this.knucklePositions.push(new THREE.Vector3());

                    // Initialize interpolation vectors
                    this.actualFingerPositions.push(new THREE.Vector3());
                    this.actualKnucklePositions.push(new THREE.Vector3());
                }
            },

            getNotePosition(stringIdx, fret) {
                // stringIdx 1=e (high) to 6=E (low)
                // Array index is inverted: strings[0] is high e
                const idx = 6 - stringIdx; 
                if(!this.strings[idx]) return new THREE.Vector3();
                
                const y = this.strings[idx].y;
                let x;
                if (fret === 0) x = this.fretPositions[0] - 0.5;
                else x = (this.fretPositions[fret] + this.fretPositions[fret - 1]) / 2;
                
                return new THREE.Vector3(x, 0.5, y);
            },

            setChord(name) {
                if (!LibraryManager.data.chords[name]) return;
                
                // 1. Update State
                // Apply offsets
                const offset = LibraryManager.data.offsets[name] || { x: 0, y: 0, z: 0 };
                this.handOffset.set(offset.x, offset.y, offset.z);
                this.currentChordName = name;
                uiManager.updateUIForChord(name, offset);

                // 2. Setup Targets
                this.updatePositions();
            },

            updatePositions() {
                const name = this.currentChordName;
                if(!name || !LibraryManager.data.chords[name]) return;
                if(!this.markerGroup) return; // Guard not initialized

                this.fingerTargets = [null, null, null, null];
                this.markerGroup.clear();
                
                const chordObj = LibraryManager.data.chords[name];
                const chordNotes = chordObj.positions || chordObj; // Fallback for old data if any
                let avgX = 0, avgZ = 0, count = 0;
                
                // Group by finger to detect barre
                const fingerNotes = [[], [], [], []];

                chordNotes.forEach(note => {
                    const pos = this.getNotePosition(note.string, note.fret);
                    fingerNotes[note.finger].push({ ...note, pos });
                    
                    // Visual Marker
                    if (note.fret > 0) {
                        const m = new THREE.Mesh(
                            new THREE.CircleGeometry(0.12, 16),
                            new THREE.MeshBasicMaterial({ color: this.fingerColors[note.finger], transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                        );
                        m.rotation.x = -Math.PI / 2;
                        m.position.set(pos.x, 0.16, pos.z);
                        this.markerGroup.add(m);

                        // Ring
                        const r = new THREE.Mesh(
                            new THREE.RingGeometry(0.14, 0.17, 16),
                            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
                        );
                        r.rotation.x = -Math.PI / 2;
                        r.position.set(pos.x, 0.162, pos.z);
                        this.markerGroup.add(r);
                    }
                    avgX += pos.x;
                    avgZ += pos.z;
                    count++;
                });

                // Assign Targets with Barre Logic
                for(let i=0; i<4; i++) {
                    const notes = fingerNotes[i];
                    if (notes.length > 0) {
                        // If multiple notes OR notes span a wide range
                        // For now, strict count > 1 implies barre usage
                        if (notes.length > 1) {
                            this.fingers[i].isBarre = true;
                            
                            // Sort by Z (string position) to find span
                            // Based on analysis: String 6 is at Z ~ 0.7, String 1 at Z ~ -0.7
                            // Hand is at Z < -0.7. So Tip should go to Max Z.
                            notes.sort((a,b) => b.pos.z - a.pos.z);
                            
                            const maxNote = notes[0];
                            const minNote = notes[notes.length-1];
                            
                            // Extend tip to be exactly at the top string (or just slightly over)
                            const tipPos = maxNote.pos.clone();
                            // If this note is on Low E (string 6), pos.z is ~0.7.
                            // User wants it "exactly at the top". Let's assume clamping to 0.75 for a tiny overlap
                            // but basically ending there.
                            tipPos.z = Math.max(0.72, tipPos.z + 0.05); 
                            this.fingerTargets[i] = tipPos;

                            // === BARRE HIGHLIGHT ===
                            // Create a visual indicator for the barre text/area
                            const zCenter = (minNote.pos.z + maxNote.pos.z) / 2;
                            const zSize = (maxNote.pos.z - minNote.pos.z) + 0.4; // +padding
                            
                            const highlight = new THREE.Mesh(
                                new THREE.BoxGeometry(0.35, 0.04, zSize),
                                new THREE.MeshBasicMaterial({ 
                                    color: this.fingerColors[i], 
                                    transparent: true, 
                                    opacity: 0.3 
                                })
                            );
                            // Position slightly above fretboard
                            highlight.position.set(maxNote.pos.x, 0.12, zCenter);
                            this.markerGroup.add(highlight);

                        } else {
                            this.fingers[i].isBarre = false;
                            this.fingerTargets[i] = notes[0].pos;
                        }
                    } else {
                        this.fingers[i].isBarre = false; 
                    }
                }

                if (count > 0) { avgX /= count; avgZ /= count; }

                // Auto-adjust hand position for Barre chords to reduce stretching
                // If any finger is barre, we usually push the wrist forward and lower
                let barreZ = 0;
                let barreY = 0;
                
                // --- RIGID HAND CORRECTION ---
                // If a finger is barre, it MUST start perpendicular to strict X.
                // To keep the hand connected, we must shift the entire baseX to satisfy this constraint.
                // We prioritize the lowest index barre (usually index finger).
                let baseX = avgX + this.handOffset.x;
                const barreFingerIdx = this.fingers.findIndex(f => f.isBarre);
                
                if(barreFingerIdx !== -1) {
                     barreZ = 0.6; // Push hand forward
                     barreY = -0.2; // Flatten wrist
                     
                     // RIGID X-ALIGNMENT with FLEXIBILITY
                     // We want the finger start to be perpendicular (fixed distance),
                     // BUT we also want to allow the user's manual offset (this.handOffset.x) to shift the whole hand.
                     // Previously, using tipX - offset.x completely OVERRODE user's shift if avgX wasn't perfectly aligned.
                     
                     // 1. Calculate the "Ideal" BaseX for perfect perpendicularity
                     const tipX = this.fingerTargets[barreFingerIdx].x;
                     const idealBaseX = tipX - this.fingerConfigs[barreFingerIdx].offset.x;

                     // 2. Allow user offset relative to that ideal position
                     // Note: We ignore avgX here because for a barre, the anchor is the barre finger, not the average of dots.
                     // User request: "When barre, allow only +- 0.5 in the X direction."
                     let xShift = this.handOffset.x;
                     
                     // Strictly clamp the manual offset for barre chords
                     if(xShift > 0.5) xShift = 0.5;
                     if(xShift < -0.5) xShift = -0.5;

                     baseX = idealBaseX + xShift;

                     // RIGID Y-ALIGNMENT (Prevent separation)
                     // If we are barring, the barre finger MUST be flat at Y=0.48.
                     // But if we only override that one finger, the others slide away when 'knuckleY' follows the Y-slider.
                     // We must calc 'knuckleY' such that the barre finger lands at 0.48 naturally.
                     // idealBaseY + stagger = 0.48  => ideaBaseY = 0.48 - stagger
                     const yStagger = [0, 0.08, 0.06, -0.04][barreFingerIdx];
                     barreY = (0.48 - yStagger) - (-0.4); // Subtract baseline (-0.4) so adding it back cancels out
                     
                     // RIGID Y-LOCK for Barre
                     // User Request: "with barre, do not allow any Y movement at all."
                     // We force the offset to 0 so the hand stays perfectly at the calculated ideal height.
                     this.currentYOffset = 0; 
                } else {
                     this.currentYOffset = this.handOffset.y;
                }

                // 3. Position Hand Base
                const knuckleY = -0.4 + this.currentYOffset + barreY;
                
                // FIXED Z-START
                // User requirement: "Do not allow user change Z, fingers should always start at the top of the freat"
                // We pin the knuckles to the "start" edge of the fretboard (High E side, Z ~ -0.9)
                // We ignore avgZ (target averaging) and handOffset.z (user slider).
                const fixedKnuckleZ = -0.95; 
                
                // We still allow barreZ shift if it helps reach? 
                // Actually user said "Always start at the top". Let's stick to the fixed edge relative to neck.
                const knuckleZ = fixedKnuckleZ; 

                for (let i = 0; i < 4; i++) {
                    const config = this.fingerConfigs[i];
                    const yStagger = [0, 0.08, 0.06, -0.04][i];
                    const zStagger = i * 0.05;
                    this.knucklePositions[i].set(
                        baseX + config.offset.x,
                        knuckleY + yStagger,
                        knuckleZ + zStagger
                    );
                }

                // 4. Handle Unused Fingers (Smart Parking)
                for (let i = 0; i < 4; i++) {
                    if (!this.fingerTargets[i]) {
                        // Interpolate position between active neighbors
                        let left = -1, right = -1;
                        for(let j=i-1; j>=0; j--) if(this.fingerTargets[j]) { left = j; break; }
                        for(let j=i+1; j<4; j++) if(this.fingerTargets[j]) { right = j; break; }
                        
                        let tx = baseX + this.fingerConfigs[i].offset.x;
                        let tz = avgZ;
                        
                        if (left !== -1 && right !== -1) {
                            const rangeTotal = this.fingerConfigs[right].offset.x - this.fingerConfigs[left].offset.x;
                            const myRel = (this.fingerConfigs[i].offset.x - this.fingerConfigs[left].offset.x) / rangeTotal;
                            tx = this.fingerTargets[left].x + (this.fingerTargets[right].x - this.fingerTargets[left].x) * myRel;
                            tz = this.fingerTargets[left].z + (this.fingerTargets[right].z - this.fingerTargets[left].z) * myRel;
                        } else if (left !== -1) {
                            tx = Math.max(tx, this.fingerTargets[left].x + 0.2);
                            tz = this.fingerTargets[left].z;
                        } else if (right !== -1) {
                            tx = Math.min(tx, this.fingerTargets[right].x - 0.2);
                            tz = this.fingerTargets[right].z;
                        }

                        this.fingerTargets[i] = new THREE.Vector3(tx, 1.1, tz);
                    }
                }
            },

            updateCameraInfo() {
                const info = document.getElementById('camera-info');
                if(!info) return;
                const p = this.camera.position;
                info.innerHTML = `Cam: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update IK
                let palmCenter = new THREE.Vector3();
                let activeCount = 0;

                for (let i = 0; i < 4; i++) {
                    const targetF = this.fingerTargets[i];
                    const targetK = this.knucklePositions[i];

                    // Only update if we have valid targets
                    if (targetF && targetK) {
                        
                        // Initialization Snap (if zero)
                        if(this.actualKnucklePositions[i].lengthSq() === 0) {
                            this.actualKnucklePositions[i].copy(targetK);
                            this.actualFingerPositions[i].copy(targetF);
                        }

                        // Smooth Transition (Lerp)
                        this.actualFingerPositions[i].lerp(targetF, this.transitionSpeed);
                        this.actualKnucklePositions[i].lerp(targetK, this.transitionSpeed);

                        // Track for palm position
                        palmCenter.add(this.actualKnucklePositions[i]);
                        activeCount++;

                        // Apply to IK
                        this.fingers[i].setTarget(this.actualFingerPositions[i]);
                        this.fingers[i].update(this.actualKnucklePositions[i]);
                    }
                }
                
                // Update Palm
                if (this.palmMesh && activeCount > 0) {
                    palmCenter.divideScalar(activeCount);
                    // Position palm slightly behind and below average knuckle position
                    this.palmMesh.position.set(palmCenter.x, palmCenter.y - 0.15, palmCenter.z + 0.6);
                    
                    // Simple rotation to follow the "slope" of the hand?
                    // For now, fixed rotation looks stable enough for this view
                    this.palmMesh.rotation.x = -0.2; 
                }

                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            },

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        // ==========================================
        // FINGER CLASS
        // ==========================================
        class Finger {
            constructor(color, offset, lengths, scene) {
                this.lengths = lengths;
                this.segments = [];
                this.joints = [];
                this.targetPos = new THREE.Vector3();
                this.isBarre = false;

                // More realistic material
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 0.5,
                    metalness: 0.1
                });
                const jointMat = new THREE.MeshStandardMaterial({
                    color: 0xbaa085, // skin tone for joints to contrast
                    roughness: 0.6
                });

                // Segments
                for(let l of lengths) {
                     // Tapered Cylinder for realism
                    const seg = new THREE.Mesh(new THREE.CylinderGeometry(0.085, 0.1, l, 8), mat);
                    seg.castShadow = true;
                    scene.add(seg);
                    this.segments.push(seg);
                }
                // Joints
                for(let i=0; i<4; i++) {
                    const joint = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), jointMat);
                    joint.castShadow = true;
                    scene.add(joint);
                    this.joints.push(joint);
                }
            }

            setTarget(pos) { 
                this.targetPos.copy(pos); 
            }

            update(knucklePos) {
                // Bezier IK
                // Clone knucklePos to avoid mutating the source animation vector directly during physics correction
                const p0 = knucklePos.clone();
                const p2 = this.targetPos.clone(); // Clone target too just in case
                
                let pos;

                const totalLen = this.lengths.reduce((a,b)=>a+b,0);
                const t1 = this.lengths[0]/totalLen;
                const t2 = (this.lengths[0] + this.lengths[1])/totalLen;

                if (this.isBarre) {
                    const barreHeight = 0.42; // Low enough to intersect strings (Pressing down)
                    p2.y = barreHeight; 
                    
                    // For barre, we want a linear finger on the fretboard
                    // Function to get point on line between projected P0 and P2
                    const getBarrePoint = (t) => {
                        return new THREE.Vector3(
                            p0.x + (p2.x - p0.x) * t,
                            barreHeight, 
                            p0.z + (p2.z - p0.z) * t
                        );
                    };

                    // Joint 1 (End of Proximal) & Joint 2 (End of Intermediate)
                    // We place them at barreHeight to ensure the meaty part is flat
                    const j1 = getBarrePoint(t1);
                    const j2 = getBarrePoint(t2);
                    
                    pos = [p0, j1, j2, p2];

                } else {
                    // Standard Arc for Open Chords
                    const mid = new THREE.Vector3().addVectors(p0, p2).multiplyScalar(0.5);
                    const dist = p0.distanceTo(p2);
                    
                    // Height arch calculation
                    mid.y = Math.max(p0.y, p2.y) + 0.6 + (dist * 0.15);
                    
                    // Arch OUTWARDS away from the neck to avoid clipping
                    // If hand is on Positive side (Z>0), pull mid more Positive.
                    // If hand is on Negative side (Z<0), pull mid more Negative.
                    // Neck center is Z~0.
                    if (p0.z > 0) mid.z += 0.5;
                    else mid.z -= 0.5;

                    // Bezier Point Calc
                    const getP = (t) => {
                        const u = 1 - t;
                        return new THREE.Vector3(
                            u*u*p0.x + 2*u*t*mid.x + t*t*p2.x,
                            u*u*p0.y + 2*u*t*mid.y + t*t*p2.y,
                            u*u*p0.z + 2*u*t*mid.z + t*t*p2.z
                        );
                    };

                    pos = [p0, getP(t1), getP(t2), p2];
                }

                // STRICT COLLISION COSTRAINTS
                // 1. Z-Limit: Keep fingers within the fretboard width (Top/Low E to Bottom/High E)
                // We use limits derived from the barre geometry: Max ~0.75 (Low E), Min ~ -0.9 (just below High E).
                const maxZ = 0.75;
                const minZ = -0.95;

                // 2. Y-Limit: Prevent sinking into the neck
                const safeHeight = 0.38; 

                pos.forEach(p => {
                    // Clamp Z position (Width)
                    if(p.z > maxZ) p.z = maxZ;
                    if(p.z < minZ) p.z = minZ;

                    // Clamp Y position (Height)
                    // Since Z is now strictly within the neck breadth, we just enforce height for all points
                    if(p.y < safeHeight) {
                        p.y = safeHeight;
                    }
                });

                // Apply to meshes
                for(let i=0; i<4; i++) this.joints[i].position.copy(pos[i]);
                for(let i=0; i<3; i++) {
                    const center = new THREE.Vector3().lerpVectors(pos[i], pos[i+1], 0.5);
                    this.segments[i].position.copy(center);
                    this.segments[i].lookAt(pos[i+1]);
                    this.segments[i].rotateX(Math.PI/2);
                    // Stretch to fit
                    const d = pos[i].distanceTo(pos[i+1]);
                    this.segments[i].scale.set(1, d / this.lengths[i], 1);
                }
            }
        }

        // ==========================================
        // UI MANAGER
        // ==========================================
        const uiManager = {
            updateUIForChord(name, offset) {
                // Highlight button
                document.querySelectorAll('.chord-btn').forEach(b => {
                    b.classList.remove('active');
                    if(b.textContent === name) b.classList.add('active');
                });
                document.getElementById('current-chord-display').textContent = name;

                // Set Sliders
                ['x', 'y'].forEach(axis => {
                    const input = document.querySelector(`input[oninput*="'${axis}'"]`);
                    if(input && offset[axis] !== undefined) input.value = offset[axis];
                    const disp = document.getElementById(`offset-${axis}`);
                    if(disp && offset[axis] !== undefined) disp.textContent = parseFloat(offset[axis]).toFixed(1);
                });

                // Render Diagram
                this.renderDiagram(name);
            },

            updateHandOffset(axis, value) {
                value = parseFloat(value);
                GuitarApp.handOffset[axis] = value;
                document.getElementById(`offset-${axis}`).textContent = value.toFixed(1);
                if(GuitarApp.currentChordName) GuitarApp.updatePositions();
            },

            saveCurrentOffset() {
                const name = GuitarApp.currentChordName;
                if(!name) return;
                const ho = GuitarApp.handOffset;
                LibraryManager.data.offsets[name] = { x: ho.x, y: ho.y };
                LibraryManager.save();
                const btn = document.querySelector(`button[onclick="uiManager.saveCurrentOffset()"]`);
                const old = btn.textContent;
                btn.textContent = "Saved!"; 
                setTimeout(()=>btn.textContent=old, 1000);
            },

            resetCurrentOffset() {
                const name = GuitarApp.currentChordName;
                if (!DEFAULTS.offsets[name]) return; 
                const def = DEFAULTS.offsets[name];
                LibraryManager.data.offsets[name] = { ...def };
                LibraryManager.save();
                GuitarApp.setChord(name); 
            },

            renderChordButtons() {
                const container = document.getElementById('chord-buttons-container');
                container.innerHTML = '';
                Object.keys(LibraryManager.data.chords).forEach(key => {
                    const btn = document.createElement('button');
                    btn.className = 'chord-btn';
                    if (GuitarApp.currentChordName === key) btn.classList.add('active');
                    btn.textContent = key;
                    btn.onclick = () => GuitarApp.setChord(key);
                    btn.oncontextmenu = (e) => {
                        e.preventDefault();
                        editChord(key);
                    };
                    container.appendChild(btn);
                });
            },

            renderDiagram(chordName) {
                const fullChord = LibraryManager.data.chords[chordName];
                const chord = fullChord.positions || fullChord; // fallback
                const tags = fullChord.tags || [];

                const fingerNames = ['Index (1)', 'Middle (2)', 'Ring (3)', 'Pinky (4)'];
                const stringNames = ['e', 'B', 'G', 'D', 'A', 'E'];
                
                let html = '';
                if(tags.length) {
                    html += `<div style="margin-bottom:10px; font-size: 0.8em; color: var(--accent-color);">
                        ${tags.map(t => `<span style="border:1px solid #555; padding:2px 6px; border-radius:4px; margin-right:4px;">${t}</span>`).join('')}
                    </div>`;
                }

                chord.forEach(note => {
                    html += `<div class="finger-row">
                        <span class="finger-name">${fingerNames[note.finger]}:</span>
                        <span class="finger-pos">Str ${stringNames[note.string-1]}, Fr ${note.fret}</span>
                    </div>`;
                });
                document.getElementById('finger-list').innerHTML = html;

                // Ascii board
                let board = '<pre>     Fret: 0   1   2   3   4\n          nut ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ\n';
                for(let s=1; s<=6; s++) {
                    const lbl = stringNames[s-1].padEnd(6);
                    let line = lbl + '‚îÇ';
                    for(let f=1; f<=4; f++) {
                        const hit = chord.find(c => c.string === s && c.fret === f);
                        line += hit ? ` ${hit.finger+1} ‚îÇ` : '‚îÄ‚îÄ‚îÄ‚îÇ';
                    }
                    board += line + '\n';
                }
                board += '</pre>';
                document.getElementById('fretboard-text').innerHTML = board;
            }
        };

        // ==========================================
        // EXPORT GLOBALS FOR HTML
        // ==========================================
        window.libraryManager = LibraryManager;
        window.uiManager = uiManager;
        
        // Modal Logic Globals
        window.togglePanel = function() {
            const p = document.getElementById('panel-content');
            const b = document.getElementById('toggle-btn');
            if(p.style.display === 'none') { 
                p.style.display = 'block'; 
                b.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>'; 
            } else { 
                p.style.display = 'none'; 
                b.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>'; 
            }
        }

        window.openModal = function() {
            document.getElementById('chordModal').style.display = 'block';
            setupForm(); // For new chord
        }
        window.closeModal = function() { document.getElementById('chordModal').style.display = 'none'; }
        
        window.editChord = function(name) {
            document.getElementById('chordModal').style.display = 'block';
            document.getElementById('edit-name').value = name;
            setupForm(name);
        }

        function setupForm(name) {
            const container = document.getElementById('string-inputs');
            container.innerHTML = '';
            
            const chordObj = name ? LibraryManager.data.chords[name] : {};
            const positions = chordObj.positions || (Array.isArray(chordObj) ? chordObj : []);
            const tags = chordObj.tags || [];

            // Add Tag Input
            const tagInput = document.createElement('div');
            tagInput.className = 'form-group';
            tagInput.innerHTML = `
                <label>Tags</label>
                <input type="text" id="edit-tags" value="${tags.join(', ')}" placeholder="e.g. Major, Open, Barre">
            `;
            container.appendChild(tagInput);

            // Divider
            const divider = document.createElement('div');
            divider.className = 'divider';
            container.appendChild(divider);

            const labels = ['High e', 'B', 'G', 'D', 'A', 'Low E'];

            // Header for strings
            const header = document.createElement('div');
            header.style.display = 'grid';
            header.style.gridTemplateColumns = '60px 1fr 1fr';
            header.style.marginBottom = '8px';
            header.style.fontSize = '0.8rem';
            header.style.opacity = '0.7';
            header.innerHTML = '<span>String</span><span>Fret</span><span>Finger</span>';
            container.appendChild(header);

            for(let s=1; s<=6; s++) {
                const note = positions.find(n => n.string === s);
                const fret = note ? note.fret : 0;
                const finger = note ? note.finger : -1;
                
                const div = document.createElement('div');
                div.className = 'string-row';
                div.innerHTML = `
                    <label class="string-label">${labels[s-1]}</label>
                    <input type="number" min="0" max="24" id="fret-${s}" value="${fret}" class="fret-input">
                    <select id="finger-${s}" class="finger-select">
                        <option value="-1" ${finger===-1?'selected':''}>-</option>
                        <option value="0" ${finger===0?'selected':''}>Index</option>
                        <option value="1" ${finger===1?'selected':''}>Middle</option>
                        <option value="2" ${finger===2?'selected':''}>Ring</option>
                        <option value="3" ${finger===3?'selected':''}>Pinky</option>
                    </select>
                `;
                container.appendChild(div);
            }
            
            const delBtn = document.getElementById('delete-chord-btn');
            if(name) {
                 delBtn.style.display = 'block';
                 delBtn.onclick = () => window.deleteChord(name);
            } else {
                delBtn.style.display = 'none';
            }
        }

        window.saveChordFromForm = function() {
            const name = document.getElementById('edit-name').value.trim();
            if(!name) return alert("Name required");
            
            // Get Tags
            const tagStr = document.getElementById('edit-tags').value;
            const tags = tagStr.split(',').map(s => s.trim()).filter(s => s.length > 0);

            // Get Positions
            const positions = [];
            for(let s=1; s<=6; s++) {
                const fret = parseInt(document.getElementById(`fret-${s}`).value);
                const finger = parseInt(document.getElementById(`finger-${s}`).value);
                if(finger >= 0) positions.push({string: s, fret, finger});
            }
            
            LibraryManager.data.chords[name] = { positions, tags };
            // Only set offset if new
            if(!LibraryManager.data.offsets[name]) LibraryManager.data.offsets[name] = {x:0, y:0};
            
            LibraryManager.save();
            closeModal();
            GuitarApp.setChord(name);
        }

        window.deleteChord = function(name) {
            if(confirm('Delete ' + name + '?')) {
                delete LibraryManager.data.chords[name];
                delete LibraryManager.data.offsets[name];
                LibraryManager.save();
                closeModal();
                GuitarApp.setChord(Object.keys(LibraryManager.data.chords)[0] || 'C');
            }
        };

        // --- BOOTSTRAP ---
        (async function bootstrap() {
            try {
                await LibraryManager.init();
                GuitarApp.init();

                // Build UI
                uiManager.renderChordButtons();

                // Initial Load
                const keys = Object.keys(LibraryManager.data.chords);
                const firstChord = keys.length > 0 ? keys[0] : 'C'; // Fallback
                GuitarApp.setChord(firstChord);
            } catch(e) {
                console.error("Bootstrap failed:", e);
                alert("App startup failed: " + e);
            }
        })();

    </script>
</body>
</html>
