<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Hand Simulator</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-bg: rgba(0,0,0,0.85);
            --accent-color: #4CAF50;
            --active-color: #2196F3;
            --text-color: #ffffff;
            --text-muted: #aaaaaa;
        }
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: var(--bg-color);
            width: 100vw;
            height: 100vh;
        }
        canvas { 
            display: block; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 0; 
        }
        
        /* Main UI Panel */
        #controls {
            position: absolute;
            z-index: 10;
            top: 20px;
            left: 20px;
            background: var(--panel-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: 10px;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            scrollbar-width: thin;
        }
        #controls h3 { margin: 0; font-size: 1.1em; }
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        /* Buttons */
        .btn {
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 8px 12px;
            font-size: 14px;
            transition: background 0.2s;
            color: white;
        }
        .btn:hover { opacity: 0.9; }
        
        #toggle-btn {
            background: rgba(255,255,255,0.2);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            line-height: 1;
            padding: 0;
        }
        #toggle-btn:hover { background: rgba(255,255,255,0.3); }

        .chord-btn {
            background: var(--accent-color);
            margin: 4px;
            font-size: 15px;
            flex-grow: 1;
            min-width: 60px;
        }
        .chord-btn.active { background: var(--active-color); }
        
        #manage-btn { background: #455a64; width: 100%; margin-top: 10px; }

        /* Chord Diagram & Info */
        #info {
            position: absolute;
            z-index: 10;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #chord-diagram {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-family: monospace;
        }
        #chord-diagram h4 { margin: 0 0 10px 0; color: var(--accent-color); }
        
        .finger-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9em;
        }
        .string-diagram pre { margin: 10px 0 0 0; color: #ccc; font-size: 13px; }

        /* Debug / Hand Position Controls */
        #debug-controls {
            margin-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 10px;
        }
        .control-row { display: flex; align-items: center; margin-bottom: 5px; }
        .control-row label { width: 20px; color: var(--text-muted); }
        .control-row input { flex-grow: 1; margin: 0 10px; }
        .control-row span { width: 35px; text-align: right; font-family: monospace; }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #222;
            margin: 5% auto;
            padding: 25px;
            border: 1px solid #444;
            width: 90%;
            max-width: 500px;
            color: white;
            border-radius: 8px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover { color: white; }
        
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; color: #aaa; }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
        }
        .string-row { 
            display: grid; 
            grid-template-columns: 80px 1fr 1fr; 
            gap: 10px; 
            align-items: center; 
            margin-bottom: 8px; 
            background: rgba(255,255,255,0.05);
            padding: 5px;
            border-radius: 4px;
        }
        .string-row label { margin: 0; font-weight: bold; color: #ccc;}
        
        .modal-actions {
            border-bottom: 1px solid #444;
            margin-bottom: 20px;
            padding-bottom: 10px;
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>

    <!-- CONTROL PANEL -->
    <div id="controls">
        <div class="header-row">
            <h3>üé∏ Hand Simulator</h3>
            <button id="toggle-btn" onclick="togglePanel()" class="btn">‚àí</button>
        </div>
        
        <div id="panel-content">
            <!-- Chord Buttons Grid -->
            <div id="chord-buttons-container" style="display: flex; flex-wrap: wrap;"></div>
            
            <button id="manage-btn" class="btn" onclick="openModal()">‚öôÔ∏è Manage Chords Library</button>

            <!-- Active Chord Info -->
            <div id="chord-diagram">
                <h4>üìç Finger Positions</h4>
                <div id="finger-list"></div>
                <div class="string-diagram">
                    <div id="fretboard-text"></div>
                </div>
            </div>

            <!-- Hand Transformation Controls -->
            <div id="debug-controls">
                <h4 style="margin: 0 0 10px 0; color: #ff9800;">üõ† Hand Position</h4>
                
                <div class="control-row">
                    <label>X:</label>
                    <input type="range" min="-2" max="2" step="0.1" value="0" oninput="uiManager.updateHandOffset('x', this.value)">
                    <span id="offset-x">0.0</span>
                </div>
                <div class="control-row">
                    <label>Y:</label>
                    <input type="range" min="-2" max="2" step="0.1" value="0" oninput="uiManager.updateHandOffset('y', this.value)">
                    <span id="offset-y">0.0</span>
                </div>
                <div class="control-row">
                    <label>Z:</label>
                    <input type="range" min="-2" max="2" step="0.1" value="0" oninput="uiManager.updateHandOffset('z', this.value)">
                    <span id="offset-z">0.0</span>
                </div>
                
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button onclick="uiManager.saveCurrentOffset()" class="btn" style="background: #ff9800; flex-grow: 1; font-weight: bold;">Save Position</button>
                    <button onclick="uiManager.resetCurrentOffset()" class="btn" style="background: #444;">‚Ü∫</button>
                </div>
            </div>
        </div>
    </div>

    <!-- INFO OVERLAY -->
    <div id="info">
        Drag to rotate | Scroll to zoom | Current: <span id="current-chord-display">C</span>
        <div id="camera-info" style="font-size: 0.8em; opacity: 0.7; margin-top: 5px; font-family: monospace;"></div>
    </div>

    <!-- MODAL -->
    <div id="chordModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Manage Library</h2>
            
            <div class="modal-actions">
                <button class="btn" onclick="libraryManager.exportLibrary()" style="background: #555;">üíæ Export JSON</button>
                <button class="btn" onclick="document.getElementById('importFile').click()" style="background: #555;">üìÇ Import JSON</button>
                <button class="btn" onclick="libraryManager.resetLibrary()" style="background: #d32f2f; margin-left: auto;">Reset Defaults</button>
                <input type="file" id="importFile" style="display:none" onchange="libraryManager.importLibrary(this)">
            </div>

            <h3 style="color: var(--accent-color);">Editor</h3>
            <div class="form-group">
                <label>Chord Name</label>
                <input type="text" id="edit-name" placeholder="e.g. Bm7">
            </div>

            <div id="string-inputs">
                <!-- Generated by JS -->
            </div>

            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button class="btn" onclick="saveChordFromForm()" style="background: var(--accent-color); flex-grow: 1; padding: 12px;">Save Chord</button>
                <button class="btn" id="delete-chord-btn" onclick="deleteChord()" style="background: #d32f2f; display:none;">Delete</button>
            </div>
        </div>
    </div>

    <!-- THREE.JS IMPORT MAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- APP SCRIPT -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // DATA & LIBRARY MANAGER
        // ==========================================
        const DEFAULTS = {
            chords: {
                // MAJOR
                'C': { positions: [ { string: 2, fret: 1, finger: 0 }, { string: 4, fret: 2, finger: 1 }, { string: 5, fret: 3, finger: 2 } ], tags: ['Major', 'Open'] },
                'A': { positions: [ { string: 4, fret: 2, finger: 0 }, { string: 3, fret: 2, finger: 1 }, { string: 2, fret: 2, finger: 2 } ], tags: ['Major', 'Open'] },
                'G': { positions: [ { string: 5, fret: 2, finger: 0 }, { string: 6, fret: 3, finger: 1 }, { string: 1, fret: 3, finger: 2 }, { string: 2, fret: 3, finger: 3 } ], tags: ['Major', 'Open'] },
                'E': { positions: [ { string: 3, fret: 1, finger: 0 }, { string: 5, fret: 2, finger: 1 }, { string: 4, fret: 2, finger: 2 } ], tags: ['Major', 'Open'] },
                'D': { positions: [ { string: 3, fret: 2, finger: 0 }, { string: 1, fret: 2, finger: 1 }, { string: 2, fret: 3, finger: 2 } ], tags: ['Major', 'Open'] },
                
                // MINOR
                'Am': { positions: [ { string: 2, fret: 1, finger: 0 }, { string: 4, fret: 2, finger: 1 }, { string: 3, fret: 2, finger: 2 } ], tags: ['Minor', 'Open'] },
                'Em': { positions: [ { string: 5, fret: 2, finger: 1 }, { string: 4, fret: 2, finger: 2 } ], tags: ['Minor', 'Open'] },
                'Dm': { positions: [ { string: 1, fret: 1, finger: 0 }, { string: 3, fret: 2, finger: 1 }, { string: 2, fret: 3, finger: 2 } ], tags: ['Minor', 'Open'] },

                // BARRE CHORDS (E-Shape / A-Shape roots)
                'F': { positions: [ { string: 2, fret: 1, finger: 0 }, { string: 3, fret: 2, finger: 1 }, { string: 5, fret: 3, finger: 2 }, { string: 4, fret: 3, finger: 3 } ], tags: ['Major', 'Barre'] }, // Simplified F
                'Bm': { positions: [ { string: 5, fret: 2, finger: 0 }, { string: 2, fret: 3, finger: 1 }, { string: 4, fret: 4, finger: 2 }, { string: 3, fret: 4, finger: 3 } ], tags: ['Minor', 'Barre'] },
                
                // 7th
                'C7': { positions: [ { string: 2, fret: 1, finger: 0 }, { string: 4, fret: 2, finger: 1 }, { string: 5, fret: 3, finger: 2 }, { string: 3, fret: 3, finger: 3 } ], tags: ['Dominant 7th', 'Open'] },
                'A7': { positions: [ { string: 4, fret: 2, finger: 0 }, { string: 2, fret: 2, finger: 1 } ], tags: ['Dominant 7th', 'Open'] },
                'E7': { positions: [ { string: 3, fret: 1, finger: 0 }, { string: 5, fret: 2, finger: 1 } ], tags: ['Dominant 7th', 'Open'] },
                'G7': { positions: [ { string: 1, fret: 1, finger: 0 }, { string: 5, fret: 2, finger: 1 }, { string: 6, fret: 3, finger: 2 } ], tags: ['Dominant 7th', 'Open'] },
                'D7': { positions: [ { string: 2, fret: 1, finger: 0 }, { string: 3, fret: 2, finger: 1 }, { string: 1, fret: 2, finger: 2 } ], tags: ['Dominant 7th', 'Open'] },
                'B7': { positions: [ { string: 4, fret: 1, finger: 0 }, { string: 5, fret: 2, finger: 1 }, { string: 3, fret: 2, finger: 2 }, { string: 1, fret: 2, finger: 3 } ], tags: ['Dominant 7th', 'Open'] },

                // MAJOR 7th
                'Cmaj7': { positions: [ { string: 4, fret: 2, finger: 1 }, { string: 5, fret: 3, finger: 2 } ], tags: ['Major 7th', 'Open'] },
                'Amaj7': { positions: [ { string: 3, fret: 1, finger: 0 }, { string: 4, fret: 2, finger: 1 }, { string: 2, fret: 2, finger: 2 } ], tags: ['Major 7th', 'Open'] },
                'Fmaj7': { positions: [ { string: 2, fret: 1, finger: 0 }, { string: 3, fret: 2, finger: 1 }, { string: 4, fret: 3, finger: 2 } ], tags: ['Major 7th', 'Open'] },

                // SUSPENDED
                'Dsus4': { positions: [ { string: 3, fret: 2, finger: 0 }, { string: 2, fret: 3, finger: 2 }, { string: 1, fret: 3, finger: 3 } ], tags: ['Suspended', 'Open'] },
                'Asus4': { positions: [ { string: 4, fret: 2, finger: 0 }, { string: 3, fret: 2, finger: 1 }, { string: 2, fret: 3, finger: 2 } ], tags: ['Suspended', 'Open'] },

            },
            offsets: {
                // Offsets defaults - many just use 0, but good to have keys
                'C': { x: 0, y: 0, z: 0 },
                'A': { x: -1, y: 0.4, z: 0 },
                'G': { x: -0.3, y: 1, z: 0.2 },
                'E': { x: -0.1, y: 0.8, z: 0 },
                'D': { x: -1, y: 0, z: 0 },
                'F': { x: 0, y: 0, z: 0 },
                'Am': { x: 0, y: 0, z: 0 },
                'Em': { x: 0, y: 0, z: 0 },
                'Dm': { x: 0, y: 0, z: 0 },
                'Bm': { x: -1, y: 0, z: 0 },
                'C7': { x: 0, y: 0, z: 0 },
                'A7': { x: -1, y: 0.4, z: 0 },
                'E7': { x: -0.1, y: 0.8, z: 0 },
                'G7': { x: -0.3, y: 1, z: 0.2 },
                'D7': { x: -1, y: 0, z: 0 },
                'B7': { x: 0, y: 0, z: 0 },
                'Cmaj7': { x: 0, y: 0, z: 0 },
                'Amaj7': { x: -1, y: 0.4, z: 0 },
                'Fmaj7': { x: 0, y: 0, z: 0 },
                'Dsus4': { x: -1, y: 0, z: 0 },
                'Asus4': { x: -1, y: 0.4, z: 0 },
            }
        };

        const LibraryManager = {
            data: { chords: {}, offsets: {} },

            init() {
                const saved = localStorage.getItem('guitarChordLibrary');
                if (saved) {
                    try {
                        let parsed = JSON.parse(saved);
                        
                        // MIGRATION / VALIDATION check
                        let dirty = false;
                        if(parsed.chords) {
                            for(let k in parsed.chords) {
                                if(Array.isArray(parsed.chords[k])) {
                                    parsed.chords[k] = { positions: parsed.chords[k], tags: [] };
                                    dirty = true;
                                }
                            }
                        }

                        this.data = parsed;
                        // Structure check
                        if(!this.data.chords) this.data.chords = JSON.parse(JSON.stringify(DEFAULTS.chords));
                        if(!this.data.offsets) this.data.offsets = JSON.parse(JSON.stringify(DEFAULTS.offsets));
                        
                        if(dirty) this.save();

                    } catch(e) { console.error("Corrupt library", e); this.resetLibrary(); }
                } else {
                    this.resetDataToDefaults();
                }
            },

            resetDataToDefaults() {
                this.data.chords = JSON.parse(JSON.stringify(DEFAULTS.chords));
                this.data.offsets = JSON.parse(JSON.stringify(DEFAULTS.offsets));
            },

            save() {
                localStorage.setItem('guitarChordLibrary', JSON.stringify(this.data));
                uiManager.renderChordButtons();
            },

            resetLibrary() {
                if(confirm("Reset entire library to defaults?")) {
                    localStorage.removeItem('guitarChordLibrary');
                    localStorage.removeItem('guitarHandOffsets');
                    this.resetDataToDefaults();
                    this.save();
                    window.location.reload(); 
                }
            },

            exportLibrary() {
                const yamlStr = jsyaml.dump(this.data, { indent: 2, lineWidth: -1 });
                const blob = new Blob([yamlStr], {type: "text/yaml;charset=utf-8"});
                const url = URL.createObjectURL(blob);
                const anchor = document.createElement('a');
                anchor.href = url;
                anchor.download = "guitar_chords.yaml";
                anchor.click();
            },

            importLibrary(input) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = jsyaml.load(e.target.result);
                        if (imported && imported.chords && imported.offsets) {
                            
                            // Validate Structure
                            for(let k in imported.chords) {
                                // Fix legacy imports if any
                                if(Array.isArray(imported.chords[k])) {
                                    imported.chords[k] = { positions: imported.chords[k], tags: [] };
                                }
                            }

                            this.data = imported;
                            this.save();
                            alert("Library imported successfully!");
                            closeModal();
                            GuitarApp.setChord(Object.keys(this.data.chords)[0]);
                        } else { alert("Invalid file structure"); }
                    } catch(err) { alert("Invalid YAML file: " + err); }
                };
                reader.readAsText(file);
            }
        };

        // ==========================================
        // 3D SCENE & ENGINE
        // ==========================================
        const GuitarApp = {
            scene: null, camera: null, renderer: null, controls: null,
            neckGroup: null, handGroup: null, markerGroup: null,
            fingers: [], knucklePositions: [],
            currentChordName: null,
            handOffset: new THREE.Vector3(),
            palmPosition: new THREE.Vector3(-4, -1, 1.5), // Base Palm Pos
            fingerTargets: [null, null, null, null],
            
            // Animation State
            actualFingerPositions: [],
            actualKnucklePositions: [],
            transitionSpeed: 0.15, // Speed of interpolation

            // Configs
            strings: [],
            fretPositions: [], 
            stringColors: [0xe8e8e8, 0xe0e0e0, 0xd8d8d8, 0xb8b8b8, 0xa8a8a8, 0x989898],
            fingerColors: [0x00ffff, 0xffff00, 0xff8800, 0xff88ff],
            skinTones: [0xf5c9a6, 0xf2c4a0, 0xf0c19a, 0xeebb94],
            fingerConfigs: [
                { offset: new THREE.Vector3(-0.35, 0, 0), lengths: [0.5, 0.4, 0.3] },   // Index
                { offset: new THREE.Vector3(-0.10, 0, 0), lengths: [0.58, 0.45, 0.32] },  // Middle
                { offset: new THREE.Vector3(0.15, 0, 0), lengths: [0.54, 0.42, 0.3] },   // Ring
                { offset: new THREE.Vector3(0.40, 0, 0), lengths: [0.44, 0.35, 0.26] }   // Pinky
            ],

            init() {
                // Setup Three.js Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(-1.7, 7.2, 2.7);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.target.set(-2.4, 0.7, -0.3);
                this.controls.addEventListener('change', () => this.updateCameraInfo());

                this.addLights();
                this.buildNeck();
                this.buildHand();
                
                this.updateCameraInfo();
                this.animate();

                // Listeners
                window.addEventListener('resize', () => this.onResize());
            },

            addLights() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambient);
                const dir = new THREE.DirectionalLight(0xffffff, 1);
                dir.position.set(5, 10, 5);
                dir.castShadow = true;
                this.scene.add(dir);
            },

            buildNeck() {
                this.neckGroup = new THREE.Group();
                this.scene.add(this.neckGroup);

                // Fretboard
                const board = new THREE.Mesh(
                    new THREE.BoxGeometry(14, 0.3, 2),
                    new THREE.MeshStandardMaterial({ color: 0x3d2314 })
                );
                board.receiveShadow = true;
                this.neckGroup.add(board);

                // Frets
                const scaleLength = 12;
                const nutX = -6;
                for (let i = 0; i <= 12; i++) {
                    const dist = scaleLength - (scaleLength / Math.pow(2, i / 12));
                    const fretX = nutX + dist;
                    this.fretPositions.push(fretX);
                    
                    const fret = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.1, 1.8),
                        new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 })
                    );
                    fret.position.set(fretX, 0.2, 0);
                    this.neckGroup.add(fret);

                    if ([3, 5, 7, 9, 12].includes(i)) {
                        const dot = new THREE.Mesh(
                            new THREE.CircleGeometry(0.1, 16),
                            new THREE.MeshStandardMaterial({ color: 0xffffff })
                        );
                        dot.rotation.x = -Math.PI / 2;
                        dot.position.set(fretX - 0.3, 0.16, 0);
                        this.neckGroup.add(dot);
                    }
                }

                // Strings
                for (let i = 0; i < 6; i++) {
                    const thickness = 0.015 + i * 0.005;
                    const yPos = 0.7 - i * 0.28;
                    const strMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(thickness, thickness, 13, 8),
                        new THREE.MeshStandardMaterial({ color: this.stringColors[i], metalness: 0.9, roughness: 0.3 })
                    );
                    strMesh.rotation.z = Math.PI / 2;
                    strMesh.position.set(0, 0.35, yPos);
                    this.neckGroup.add(strMesh);
                    this.strings.push({ mesh: strMesh, y: yPos });
                }
            },

            buildHand() {
                this.handGroup = new THREE.Group();
                this.scene.add(this.handGroup);
                
                this.markerGroup = new THREE.Group();
                this.scene.add(this.markerGroup);

                // Initialize Fingers
                for (let i = 0; i < 4; i++) {
                    const fConfig = this.fingerConfigs[i];
                    const f = new Finger(this.skinTones[i], fConfig.offset, fConfig.lengths, this.scene);
                    this.fingers.push(f);
                    this.knucklePositions.push(new THREE.Vector3());

                    // Initialize interpolation vectors
                    this.actualFingerPositions.push(new THREE.Vector3());
                    this.actualKnucklePositions.push(new THREE.Vector3());
                }
            },

            getNotePosition(stringIdx, fret) {
                // stringIdx 1=e (high) to 6=E (low)
                // Array index is inverted: strings[0] is high e
                const idx = 6 - stringIdx; 
                if(!this.strings[idx]) return new THREE.Vector3();
                
                const y = this.strings[idx].y;
                let x;
                if (fret === 0) x = this.fretPositions[0] - 0.5;
                else x = (this.fretPositions[fret] + this.fretPositions[fret - 1]) / 2;
                
                return new THREE.Vector3(x, 0.5, y);
            },

            setChord(name) {
                if (!LibraryManager.data.chords[name]) return;
                
                // 1. Update State
                // Apply offsets
                const offset = LibraryManager.data.offsets[name] || { x: 0, y: 0, z: 0 };
                this.handOffset.set(offset.x, offset.y, offset.z);
                this.currentChordName = name;
                uiManager.updateUIForChord(name, offset);

                // 2. Setup Targets
                this.fingerTargets = [null, null, null, null];
                this.markerGroup.clear();
                
                const chordObj = LibraryManager.data.chords[name];
                const chordNotes = chordObj.positions || chordObj; // Fallback for old data if any
                let avgX = 0, avgZ = 0, count = 0;

                chordNotes.forEach(note => {
                    const pos = this.getNotePosition(note.string, note.fret);
                    this.fingerTargets[note.finger] = pos;
                    
                    // Visual Marker
                    if (note.fret > 0) {
                        const m = new THREE.Mesh(
                            new THREE.CircleGeometry(0.12, 16),
                            new THREE.MeshBasicMaterial({ color: this.fingerColors[note.finger], transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                        );
                        m.rotation.x = -Math.PI / 2;
                        m.position.set(pos.x, 0.16, pos.z);
                        this.markerGroup.add(m);

                        // Ring
                        const r = new THREE.Mesh(
                            new THREE.RingGeometry(0.14, 0.17, 16),
                            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
                        );
                        r.rotation.x = -Math.PI / 2;
                        r.position.set(pos.x, 0.162, pos.z);
                        this.markerGroup.add(r);
                    }
                    avgX += pos.x;
                    avgZ += pos.z;
                    count++;
                });

                if (count > 0) { avgX /= count; avgZ /= count; }

                // 3. Position Hand Base
                const baseX = avgX + this.handOffset.x;
                const knuckleY = -0.4 + this.handOffset.y;
                const knuckleZ = avgZ - 1.2 + this.handOffset.z;

                for (let i = 0; i < 4; i++) {
                    const config = this.fingerConfigs[i];
                    const yStagger = [0, 0.08, 0.06, -0.04][i];
                    const zStagger = i * 0.05;
                    this.knucklePositions[i].set(
                        baseX + config.offset.x,
                        knuckleY + yStagger,
                        knuckleZ + zStagger
                    );
                }

                // 4. Handle Unused Fingers (Smart Parking)
                for (let i = 0; i < 4; i++) {
                    if (!this.fingerTargets[i]) {
                        // Interpolate position between active neighbors
                        let left = -1, right = -1;
                        for(let j=i-1; j>=0; j--) if(this.fingerTargets[j]) { left = j; break; }
                        for(let j=i+1; j<4; j++) if(this.fingerTargets[j]) { right = j; break; }
                        
                        let tx = baseX + this.fingerConfigs[i].offset.x;
                        let tz = avgZ;
                        
                        if (left !== -1 && right !== -1) {
                            const rangeTotal = this.fingerConfigs[right].offset.x - this.fingerConfigs[left].offset.x;
                            const myRel = (this.fingerConfigs[i].offset.x - this.fingerConfigs[left].offset.x) / rangeTotal;
                            tx = this.fingerTargets[left].x + (this.fingerTargets[right].x - this.fingerTargets[left].x) * myRel;
                            tz = this.fingerTargets[left].z + (this.fingerTargets[right].z - this.fingerTargets[left].z) * myRel;
                        } else if (left !== -1) {
                            tx = Math.max(tx, this.fingerTargets[left].x + 0.2);
                            tz = this.fingerTargets[left].z;
                        } else if (right !== -1) {
                            tx = Math.min(tx, this.fingerTargets[right].x - 0.2);
                            tz = this.fingerTargets[right].z;
                        }

                        this.fingerTargets[i] = new THREE.Vector3(tx, 0.8, tz);
                    }
                }
            },

            updateCameraInfo() {
                const info = document.getElementById('camera-info');
                if(!info) return;
                const p = this.camera.position;
                info.innerHTML = `Cam: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update IK
                for (let i = 0; i < 4; i++) {
                    const targetF = this.fingerTargets[i];
                    const targetK = this.knucklePositions[i];

                    // Only update if we have valid targets
                    if (targetF && targetK) {
                        
                        // Initialization Snap (if zero)
                        if(this.actualKnucklePositions[i].lengthSq() === 0) {
                            this.actualKnucklePositions[i].copy(targetK);
                            this.actualFingerPositions[i].copy(targetF);
                        }

                        // Smooth Transition (Lerp)
                        this.actualFingerPositions[i].lerp(targetF, this.transitionSpeed);
                        this.actualKnucklePositions[i].lerp(targetK, this.transitionSpeed);

                        // Apply to IK
                        this.fingers[i].setTarget(this.actualFingerPositions[i]);
                        this.fingers[i].update(this.actualKnucklePositions[i]);
                    }
                }
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            },

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        // ==========================================
        // FINGER CLASS
        // ==========================================
        class Finger {
            constructor(color, offset, lengths, scene) {
                this.lengths = lengths;
                this.segments = [];
                this.joints = [];
                this.targetPos = new THREE.Vector3();
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });

                // Segments
                for(let l of lengths) {
                    const seg = new THREE.Mesh(new THREE.CapsuleGeometry(0.1, l, 4, 8), mat);
                    seg.castShadow = true;
                    scene.add(seg);
                    this.segments.push(seg);
                }
                // Joints
                for(let i=0; i<4; i++) {
                    const joint = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), mat);
                    joint.castShadow = true;
                    scene.add(joint);
                    this.joints.push(joint);
                }
            }

            setTarget(pos) { this.targetPos.copy(pos); }

            update(knucklePos) {
                // Bezier IK
                const p0 = knucklePos;
                const p2 = this.targetPos;
                const mid = new THREE.Vector3().addVectors(p0, p2).multiplyScalar(0.5);
                const dist = p0.distanceTo(p2);
                
                // Height arch calculation
                mid.y = Math.max(p0.y, p2.y) + 0.6 + (dist * 0.15);
                mid.z -= 0.2; // Pull out slightly

                // Bezier Point Calc
                const getP = (t) => {
                    const u = 1 - t;
                    return new THREE.Vector3(
                        u*u*p0.x + 2*u*t*mid.x + t*t*p2.x,
                        u*u*p0.y + 2*u*t*mid.y + t*t*p2.y,
                        u*u*p0.z + 2*u*t*mid.z + t*t*p2.z
                    );
                };

                const totalLen = this.lengths.reduce((a,b)=>a+b,0);
                const t1 = this.lengths[0]/totalLen;
                const t2 = (this.lengths[0] + this.lengths[1])/totalLen;

                const pos = [p0, getP(t1), getP(t2), p2];

                // Apply to meshes
                for(let i=0; i<4; i++) this.joints[i].position.copy(pos[i]);
                for(let i=0; i<3; i++) {
                    const center = new THREE.Vector3().lerpVectors(pos[i], pos[i+1], 0.5);
                    this.segments[i].position.copy(center);
                    this.segments[i].lookAt(pos[i+1]);
                    this.segments[i].rotateX(Math.PI/2);
                    // Stretch to fit
                    const d = pos[i].distanceTo(pos[i+1]);
                    this.segments[i].scale.set(1, d / this.lengths[i], 1);
                }
            }
        }

        // ==========================================
        // UI MANAGER
        // ==========================================
        const uiManager = {
            updateUIForChord(name, offset) {
                // Highlight button
                document.querySelectorAll('.chord-btn').forEach(b => {
                    b.classList.remove('active');
                    if(b.textContent === name) b.classList.add('active');
                });
                document.getElementById('current-chord-display').textContent = name;

                // Set Sliders
                ['x', 'y', 'z'].forEach(axis => {
                    const input = document.querySelector(`input[oninput*="'${axis}'"]`);
                    if(input) input.value = offset[axis];
                    const disp = document.getElementById(`offset-${axis}`);
                    if(disp) disp.textContent = parseFloat(offset[axis]).toFixed(1);
                });

                // Render Diagram
                this.renderDiagram(name);
            },

            updateHandOffset(axis, value) {
                value = parseFloat(value);
                GuitarApp.handOffset[axis] = value;
                document.getElementById(`offset-${axis}`).textContent = value.toFixed(1);
                if(GuitarApp.currentChordName) GuitarApp.setChord(GuitarApp.currentChordName);
            },

            saveCurrentOffset() {
                const name = GuitarApp.currentChordName;
                if(!name) return;
                const ho = GuitarApp.handOffset;
                LibraryManager.data.offsets[name] = { x: ho.x, y: ho.y, z: ho.z };
                LibraryManager.save();
                const btn = document.querySelector(`button[onclick="uiManager.saveCurrentOffset()"]`);
                const old = btn.textContent;
                btn.textContent = "Saved!"; 
                setTimeout(()=>btn.textContent=old, 1000);
            },

            resetCurrentOffset() {
                const name = GuitarApp.currentChordName;
                if (!DEFAULTS.offsets[name]) return; 
                const def = DEFAULTS.offsets[name];
                LibraryManager.data.offsets[name] = { ...def };
                LibraryManager.save();
                GuitarApp.setChord(name); 
            },

            renderChordButtons() {
                const container = document.getElementById('chord-buttons-container');
                container.innerHTML = '';
                Object.keys(LibraryManager.data.chords).forEach(key => {
                    const btn = document.createElement('button');
                    btn.className = 'chord-btn';
                    if (GuitarApp.currentChordName === key) btn.classList.add('active');
                    btn.textContent = key;
                    btn.onclick = () => GuitarApp.setChord(key);
                    btn.oncontextmenu = (e) => {
                        e.preventDefault();
                        editChord(key);
                    };
                    container.appendChild(btn);
                });
            },

            renderDiagram(chordName) {
                const fullChord = LibraryManager.data.chords[chordName];
                const chord = fullChord.positions || fullChord; // fallback
                const tags = fullChord.tags || [];

                const fingerNames = ['Index (1)', 'Middle (2)', 'Ring (3)', 'Pinky (4)'];
                const stringNames = ['e', 'B', 'G', 'D', 'A', 'E'];
                
                let html = '';
                if(tags.length) {
                    html += `<div style="margin-bottom:10px; font-size: 0.8em; color: var(--accent-color);">
                        ${tags.map(t => `<span style="border:1px solid #555; padding:2px 6px; border-radius:4px; margin-right:4px;">${t}</span>`).join('')}
                    </div>`;
                }

                chord.forEach(note => {
                    html += `<div class="finger-row">
                        <span class="finger-name">${fingerNames[note.finger]}:</span>
                        <span class="finger-pos">Str ${stringNames[note.string-1]}, Fr ${note.fret}</span>
                    </div>`;
                });
                document.getElementById('finger-list').innerHTML = html;

                // Ascii board
                let board = '<pre>     Fret: 0   1   2   3   4\n          nut ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ\n';
                for(let s=1; s<=6; s++) {
                    const lbl = stringNames[s-1].padEnd(6);
                    let line = lbl + '‚îÇ';
                    for(let f=1; f<=4; f++) {
                        const hit = chord.find(c => c.string === s && c.fret === f);
                        line += hit ? ` ${hit.finger+1} ‚îÇ` : '‚îÄ‚îÄ‚îÄ‚îÇ';
                    }
                    board += line + '\n';
                }
                board += '</pre>';
                document.getElementById('fretboard-text').innerHTML = board;
            }
        };

        // ==========================================
        // EXPORT GLOBALS FOR HTML
        // ==========================================
        window.libraryManager = LibraryManager;
        window.uiManager = uiManager;
        
        // Modal Logic Globals
        window.togglePanel = function() {
            const p = document.getElementById('panel-content');
            const b = document.getElementById('toggle-btn');
            if(p.style.display==='none') { p.style.display='block'; b.textContent='‚àí'; }
            else { p.style.display='none'; b.textContent='+'; }
        }

        window.openModal = function() {
            document.getElementById('chordModal').style.display = 'block';
            setupForm(); // For new chord
        }
        window.closeModal = function() { document.getElementById('chordModal').style.display = 'none'; }
        
        window.editChord = function(name) {
            document.getElementById('chordModal').style.display = 'block';
            document.getElementById('edit-name').value = name;
            setupForm(name);
        }

        function setupForm(name) {
            const container = document.getElementById('string-inputs');
            container.innerHTML = '';
            
            const chordObj = name ? LibraryManager.data.chords[name] : {};
            const positions = chordObj.positions || (Array.isArray(chordObj) ? chordObj : []);
            const tags = chordObj.tags || [];

            // Add Tag Input
            const tagInput = document.createElement('div');
            tagInput.className = 'form-group';
            tagInput.innerHTML = `
                <label>Tags (comma separated)</label>
                <input type="text" id="edit-tags" value="${tags.join(', ')}" placeholder="e.g. Major, Open, Barre">
            `;
            container.appendChild(tagInput);

            const labels = ['High e', 'B', 'G', 'D', 'A', 'Low E'];

            for(let s=1; s<=6; s++) {
                const note = positions.find(n => n.string === s);
                const fret = note ? note.fret : 0;
                const finger = note ? note.finger : -1;
                
                const div = document.createElement('div');
                div.className = 'string-row';
                div.innerHTML = `
                    <label>${labels[s-1]}</label>
                    <input type="number" min="0" max="24" id="fret-${s}" value="${fret}">
                    <select id="finger-${s}">
                        <option value="-1" ${finger===-1?'selected':''}>-</option>
                        <option value="0" ${finger===0?'selected':''}>Index</option>
                        <option value="1" ${finger===1?'selected':''}>Middle</option>
                        <option value="2" ${finger===2?'selected':''}>Ring</option>
                        <option value="3" ${finger===3?'selected':''}>Pinky</option>
                    </select>
                `;
                container.appendChild(div);
            }
            
            const delBtn = document.getElementById('delete-chord-btn');
            if(name) {
                 delBtn.style.display = 'block';
                 delBtn.onclick = () => window.deleteChord(name);
            } else {
                delBtn.style.display = 'none';
            }
        }

        window.saveChordFromForm = function() {
            const name = document.getElementById('edit-name').value.trim();
            if(!name) return alert("Name required");
            
            // Get Tags
            const tagStr = document.getElementById('edit-tags').value;
            const tags = tagStr.split(',').map(s => s.trim()).filter(s => s.length > 0);

            // Get Positions
            const positions = [];
            for(let s=1; s<=6; s++) {
                const fret = parseInt(document.getElementById(`fret-${s}`).value);
                const finger = parseInt(document.getElementById(`finger-${s}`).value);
                if(finger >= 0) positions.push({string: s, fret, finger});
            }
            
            LibraryManager.data.chords[name] = { positions, tags };
            // Only set offset if new
            if(!LibraryManager.data.offsets[name]) LibraryManager.data.offsets[name] = {x:0, y:0, z:0};
            
            LibraryManager.save();
            closeModal();
            GuitarApp.setChord(name);
        }

        window.deleteChord = function(name) {
            if(confirm('Delete ' + name + '?')) {
                delete LibraryManager.data.chords[name];
                delete LibraryManager.data.offsets[name];
                LibraryManager.save();
                closeModal();
                GuitarApp.setChord(Object.keys(LibraryManager.data.chords)[0] || 'C');
            }
        }

        // --- BOOTSTRAP ---
        LibraryManager.init();
        GuitarApp.init();

        // Initial Load
        const firstChord = Object.keys(LibraryManager.data.chords)[0] || 'C';
        GuitarApp.setChord(firstChord);

    </script>
</body>
</html>
